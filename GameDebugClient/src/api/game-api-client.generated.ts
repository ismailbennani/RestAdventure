//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class GameApiStatusApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7056";
    }

    /**
     * Ping
     */
    ping(): Observable<void> {
        let url_ = this.baseUrl + "/game/status/ping";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPing(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPing(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class GameApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7056";
    }

    /**
     * Get game settings
     */
    getGameSettings(): Observable<GameSettings> {
        let url_ = this.baseUrl + "/game/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGameSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGameSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GameSettings>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GameSettings>;
        }));
    }

    protected processGetGameSettings(response: HttpResponseBase): Observable<GameSettings> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameSettings.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get game state
     */
    getGameState(): Observable<GameState> {
        let url_ = this.baseUrl + "/game/state";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGameState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGameState(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GameState>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GameState>;
        }));
    }

    protected processGetGameState(response: HttpResponseBase): Observable<GameState> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameState.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CharactersApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7056";
    }

    /**
     * Get characters in range
     */
    getCharactersInRange(): Observable<CharacterMinimal[]> {
        let url_ = this.baseUrl + "/game/characters";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCharactersInRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCharactersInRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CharacterMinimal[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CharacterMinimal[]>;
        }));
    }

    protected processGetCharactersInRange(response: HttpResponseBase): Observable<CharacterMinimal[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CharacterMinimal.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TeamCharactersActionsApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7056";
    }

    /**
     * Move to location
     */
    moveToLocation(characterGuid: string, locationGuid: string): Observable<void> {
        let url_ = this.baseUrl + "/game/team/characters/{characterGuid}/move/{locationGuid}";
        if (characterGuid === undefined || characterGuid === null)
            throw new Error("The parameter 'characterGuid' must be defined.");
        url_ = url_.replace("{characterGuid}", encodeURIComponent("" + characterGuid));
        if (locationGuid === undefined || locationGuid === null)
            throw new Error("The parameter 'locationGuid' must be defined.");
        url_ = url_.replace("{locationGuid}", encodeURIComponent("" + locationGuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveToLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveToLocation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMoveToLocation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TeamCharactersApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7056";
    }

    /**
     * Create character
     */
    createCharacter(request: CreateCharacterRequest): Observable<TeamCharacter> {
        let url_ = this.baseUrl + "/game/team/characters";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCharacter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCharacter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeamCharacter>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeamCharacter>;
        }));
    }

    protected processCreateCharacter(response: HttpResponseBase): Observable<TeamCharacter> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeamCharacter.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete character
     */
    deleteCharacter(characterGuid: string): Observable<void> {
        let url_ = this.baseUrl + "/game/team/characters/{characterGuid}";
        if (characterGuid === undefined || characterGuid === null)
            throw new Error("The parameter 'characterGuid' must be defined.");
        url_ = url_.replace("{characterGuid}", encodeURIComponent("" + characterGuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCharacter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCharacter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteCharacter(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TeamApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7056";
    }

    /**
     * Get team
     */
    getTeam(): Observable<Team> {
        let url_ = this.baseUrl + "/game/team";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeam(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeam(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Team>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Team>;
        }));
    }

    protected processGetTeam(response: HttpResponseBase): Observable<Team> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Team.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class GameSettings implements IGameSettings {
    maxTeamSize?: number;

    constructor(data?: IGameSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxTeamSize = _data["maxTeamSize"];
        }
    }

    static fromJS(data: any): GameSettings {
        data = typeof data === 'object' ? data : {};
        let result = new GameSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxTeamSize"] = this.maxTeamSize;
        return data;
    }
}

export interface IGameSettings {
    maxTeamSize?: number;
}

/** Game state */
export class GameState implements IGameState {
    /** The current game tick
             */
    tick!: number;
    /** Is the game paused?
             */
    paused!: boolean;
    /** If the game is started, the date at which last tick has been computed
             */
    lastTickDate!: Date;
    /** If the game is not paused, the date at which next tick will be computed
             */
    nextTickDate!: Date;

    constructor(data?: IGameState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tick = _data["tick"];
            this.paused = _data["paused"];
            this.lastTickDate = _data["lastTickDate"] ? new Date(_data["lastTickDate"].toString()) : <any>undefined;
            this.nextTickDate = _data["nextTickDate"] ? new Date(_data["nextTickDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GameState {
        data = typeof data === 'object' ? data : {};
        let result = new GameState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tick"] = this.tick;
        data["paused"] = this.paused;
        data["lastTickDate"] = this.lastTickDate ? this.lastTickDate.toISOString() : <any>undefined;
        data["nextTickDate"] = this.nextTickDate ? this.nextTickDate.toISOString() : <any>undefined;
        return data;
    }
}

/** Game state */
export interface IGameState {
    /** The current game tick
             */
    tick: number;
    /** Is the game paused?
             */
    paused: boolean;
    /** If the game is started, the date at which last tick has been computed
             */
    lastTickDate: Date;
    /** If the game is not paused, the date at which next tick will be computed
             */
    nextTickDate: Date;
}

/** Minimal character information */
export class CharacterMinimal implements ICharacterMinimal {
    /** The unique ID of the character
             */
    id!: string;
    /** The name of the character
             */
    name!: string;
    /** The class of the character
             */
    class!: CharacterClass;

    constructor(data?: ICharacterMinimal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.class = _data["class"];
        }
    }

    static fromJS(data: any): CharacterMinimal {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterMinimal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["class"] = this.class;
        return data;
    }
}

/** Minimal character information */
export interface ICharacterMinimal {
    /** The unique ID of the character
             */
    id: string;
    /** The name of the character
             */
    name: string;
    /** The class of the character
             */
    class: CharacterClass;
}

export enum CharacterClass {
    Knight = "knight",
    Mage = "mage",
    Scout = "scout",
    Dealer = "dealer",
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

/** Character */
export class TeamCharacter implements ITeamCharacter {
    /** The unique ID of the character
             */
    id!: string;
    /** The name of the character
             */
    name!: string;
    /** The class of the character
             */
    class!: CharacterClass;
    /** The current location of the character
             */
    location!: MapLocation;
    /** The result of the action that has been performed on last tick
             */
    lastActionResult?: CharacterActionResult | undefined;
    /** The action that the character has planned for the next tick
             */
    nextAction?: CharacterAction | undefined;

    constructor(data?: ITeamCharacter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.location = new MapLocation();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.class = _data["class"];
            this.location = _data["location"] ? MapLocation.fromJS(_data["location"]) : new MapLocation();
            this.lastActionResult = _data["lastActionResult"] ? CharacterActionResult.fromJS(_data["lastActionResult"]) : <any>undefined;
            this.nextAction = _data["nextAction"] ? CharacterAction.fromJS(_data["nextAction"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TeamCharacter {
        data = typeof data === 'object' ? data : {};
        let result = new TeamCharacter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["class"] = this.class;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["lastActionResult"] = this.lastActionResult ? this.lastActionResult.toJSON() : <any>undefined;
        data["nextAction"] = this.nextAction ? this.nextAction.toJSON() : <any>undefined;
        return data;
    }
}

/** Character */
export interface ITeamCharacter {
    /** The unique ID of the character
             */
    id: string;
    /** The name of the character
             */
    name: string;
    /** The class of the character
             */
    class: CharacterClass;
    /** The current location of the character
             */
    location: MapLocation;
    /** The result of the action that has been performed on last tick
             */
    lastActionResult?: CharacterActionResult | undefined;
    /** The action that the character has planned for the next tick
             */
    nextAction?: CharacterAction | undefined;
}

/** Map location minimal information */
export class MapLocationMinimal implements IMapLocationMinimal {
    /** The unique ID of the location
             */
    id!: string;
    /** The area associated with the location
             */
    area!: MapArea;
    /** The X coordinate associated with the location
             */
    positionX!: number;
    /** The Y coordinate associated with the location
             */
    positionY!: number;

    constructor(data?: IMapLocationMinimal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.area = new MapArea();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.area = _data["area"] ? MapArea.fromJS(_data["area"]) : new MapArea();
            this.positionX = _data["positionX"];
            this.positionY = _data["positionY"];
        }
    }

    static fromJS(data: any): MapLocationMinimal {
        data = typeof data === 'object' ? data : {};
        let result = new MapLocationMinimal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["area"] = this.area ? this.area.toJSON() : <any>undefined;
        data["positionX"] = this.positionX;
        data["positionY"] = this.positionY;
        return data;
    }
}

/** Map location minimal information */
export interface IMapLocationMinimal {
    /** The unique ID of the location
             */
    id: string;
    /** The area associated with the location
             */
    area: MapArea;
    /** The X coordinate associated with the location
             */
    positionX: number;
    /** The Y coordinate associated with the location
             */
    positionY: number;
}

/** Map location */
export class MapLocation extends MapLocationMinimal implements IMapLocation {
    /** The locations connected to this one
             */
    connectedLocations!: MapLocationMinimal[];

    constructor(data?: IMapLocation) {
        super(data);
        if (!data) {
            this.connectedLocations = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["connectedLocations"])) {
                this.connectedLocations = [] as any;
                for (let item of _data["connectedLocations"])
                    this.connectedLocations!.push(MapLocationMinimal.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): MapLocation {
        data = typeof data === 'object' ? data : {};
        let result = new MapLocation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.connectedLocations)) {
            data["connectedLocations"] = [];
            for (let item of this.connectedLocations)
                data["connectedLocations"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Map location */
export interface IMapLocation extends IMapLocationMinimal {
    /** The locations connected to this one
             */
    connectedLocations: MapLocationMinimal[];
}

/** Map area */
export class MapArea implements IMapArea {
    /** The unique ID of the area
             */
    id!: string;
    /** The name of the area
             */
    name!: string;

    constructor(data?: IMapArea) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): MapArea {
        data = typeof data === 'object' ? data : {};
        let result = new MapArea();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

/** Map area */
export interface IMapArea {
    /** The unique ID of the area
             */
    id: string;
    /** The name of the area
             */
    name: string;
}

/** The result of an action performed by a character */
export class CharacterActionResult implements ICharacterActionResult {
    /** The tick at which the action has been performed
             */
    tick!: number;
    /** The action
             */
    action!: CharacterAction;
    /** Has the action been successful
             */
    success!: boolean;
    /** Why the action has failed
             */
    failureReason?: string | undefined;

    constructor(data?: ICharacterActionResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.action = new CharacterAction();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tick = _data["tick"];
            this.action = _data["action"] ? CharacterAction.fromJS(_data["action"]) : new CharacterAction();
            this.success = _data["success"];
            this.failureReason = _data["failureReason"];
        }
    }

    static fromJS(data: any): CharacterActionResult {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterActionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tick"] = this.tick;
        data["action"] = this.action ? this.action.toJSON() : <any>undefined;
        data["success"] = this.success;
        data["failureReason"] = this.failureReason;
        return data;
    }
}

/** The result of an action performed by a character */
export interface ICharacterActionResult {
    /** The tick at which the action has been performed
             */
    tick: number;
    /** The action
             */
    action: CharacterAction;
    /** Has the action been successful
             */
    success: boolean;
    /** Why the action has failed
             */
    failureReason?: string | undefined;
}

/** An action performed by a character */
export class CharacterAction implements ICharacterAction {

    protected _discriminator: string;

    constructor(data?: ICharacterAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "CharacterAction";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): CharacterAction {
        data = typeof data === 'object' ? data : {};
        if (data["$type"] === "move-to-location") {
            let result = new CharacterMoveToLocationAction();
            result.init(data);
            return result;
        }
        let result = new CharacterAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$type"] = this._discriminator;
        return data;
    }
}

/** An action performed by a character */
export interface ICharacterAction {
}

/** Character moves to location */
export class CharacterMoveToLocationAction extends CharacterAction implements ICharacterMoveToLocationAction {
    /** The location to which the character is moving
             */
    locationId!: string;

    constructor(data?: ICharacterMoveToLocationAction) {
        super(data);
        this._discriminator = "move-to-location";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.locationId = _data["locationId"];
        }
    }

    static override fromJS(data: any): CharacterMoveToLocationAction {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterMoveToLocationAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locationId"] = this.locationId;
        super.toJSON(data);
        return data;
    }
}

/** Character moves to location */
export interface ICharacterMoveToLocationAction extends ICharacterAction {
    /** The location to which the character is moving
             */
    locationId: string;
}

/** Character creation options */
export class CreateCharacterRequest implements ICreateCharacterRequest {
    /** The name of the character
             */
    name!: string;
    /** The class of the character
             */
    class!: CharacterClass;

    constructor(data?: ICreateCharacterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.class = _data["class"];
        }
    }

    static fromJS(data: any): CreateCharacterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCharacterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["class"] = this.class;
        return data;
    }
}

/** Character creation options */
export interface ICreateCharacterRequest {
    /** The name of the character
             */
    name: string;
    /** The class of the character
             */
    class: CharacterClass;
}

/** Team of characters */
export class Team implements ITeam {
    /** The characters in the team
             */
    characters!: TeamCharacter[];

    constructor(data?: ITeam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.characters = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["characters"])) {
                this.characters = [] as any;
                for (let item of _data["characters"])
                    this.characters!.push(TeamCharacter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Team {
        data = typeof data === 'object' ? data : {};
        let result = new Team();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.characters)) {
            data["characters"] = [];
            for (let item of this.characters)
                data["characters"].push(item.toJSON());
        }
        return data;
    }
}

/** Team of characters */
export interface ITeam {
    /** The characters in the team
             */
    characters: TeamCharacter[];
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}