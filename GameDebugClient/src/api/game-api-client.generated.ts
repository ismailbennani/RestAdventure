//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class CharactersApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7056";
    }

    /**
     * Create character
     */
    createCharacter(request: CreateCharacterRequest): Observable<TeamCharacter> {
        let url_ = this.baseUrl + "/game/team/characters";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCharacter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCharacter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeamCharacter>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeamCharacter>;
        }));
    }

    protected processCreateCharacter(response: HttpResponseBase): Observable<TeamCharacter> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeamCharacter.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get character
     */
    getCharacter(characterGuid: string): Observable<TeamCharacter> {
        let url_ = this.baseUrl + "/game/team/characters/{characterGuid}";
        if (characterGuid === undefined || characterGuid === null)
            throw new Error("The parameter 'characterGuid' must be defined.");
        url_ = url_.replace("{characterGuid}", encodeURIComponent("" + characterGuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCharacter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCharacter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeamCharacter>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeamCharacter>;
        }));
    }

    protected processGetCharacter(response: HttpResponseBase): Observable<TeamCharacter> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeamCharacter.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete character
     */
    deleteCharacter(characterGuid: string): Observable<void> {
        let url_ = this.baseUrl + "/game/team/characters/{characterGuid}";
        if (characterGuid === undefined || characterGuid === null)
            throw new Error("The parameter 'characterGuid' must be defined.");
        url_ = url_.replace("{characterGuid}", encodeURIComponent("" + characterGuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCharacter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCharacter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteCharacter(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get character history
     * @param pageNumber (optional) The page number
     * @param pageSize (optional) The page size
     */
    searchCharacterHistory(characterGuid: string, pageNumber?: number | undefined, pageSize?: number | undefined): Observable<SearchResultOfCharacterHistoryEntry> {
        let url_ = this.baseUrl + "/game/team/characters/{characterGuid}/history?";
        if (characterGuid === undefined || characterGuid === null)
            throw new Error("The parameter 'characterGuid' must be defined.");
        url_ = url_.replace("{characterGuid}", encodeURIComponent("" + characterGuid));
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchCharacterHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchCharacterHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SearchResultOfCharacterHistoryEntry>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SearchResultOfCharacterHistoryEntry>;
        }));
    }

    protected processSearchCharacterHistory(response: HttpResponseBase): Observable<SearchResultOfCharacterHistoryEntry> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchResultOfCharacterHistoryEntry.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CombatsApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7056";
    }

    /**
     * Get combats
     */
    getCombats(characterGuid: string): Observable<Combat[]> {
        let url_ = this.baseUrl + "/game/team/characters/{characterGuid}/combats";
        if (characterGuid === undefined || characterGuid === null)
            throw new Error("The parameter 'characterGuid' must be defined.");
        url_ = url_.replace("{characterGuid}", encodeURIComponent("" + characterGuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCombats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCombats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Combat[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Combat[]>;
        }));
    }

    protected processGetCombats(response: HttpResponseBase): Observable<Combat[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Combat.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CombatsHistoryApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7056";
    }

    /**
     * Search combat history
     * @param pageNumber (optional) The page number
     * @param pageSize (optional) The page size
     */
    searchCombatHistory(characterGuid: string, combatGuid: string, pageNumber?: number | undefined, pageSize?: number | undefined): Observable<SearchResultOfCombatHistoryEntry> {
        let url_ = this.baseUrl + "/game/team/characters/{characterGuid}/combats/{combatGuid}/history?";
        if (characterGuid === undefined || characterGuid === null)
            throw new Error("The parameter 'characterGuid' must be defined.");
        url_ = url_.replace("{characterGuid}", encodeURIComponent("" + characterGuid));
        if (combatGuid === undefined || combatGuid === null)
            throw new Error("The parameter 'combatGuid' must be defined.");
        url_ = url_.replace("{combatGuid}", encodeURIComponent("" + combatGuid));
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchCombatHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchCombatHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SearchResultOfCombatHistoryEntry>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SearchResultOfCombatHistoryEntry>;
        }));
    }

    protected processSearchCombatHistory(response: HttpResponseBase): Observable<SearchResultOfCombatHistoryEntry> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchResultOfCombatHistoryEntry.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Search archived combats
     * @param pageNumber (optional) The page number
     * @param pageSize (optional) The page size
     */
    searchArchivedCombats(characterGuid: string, pageNumber?: number | undefined, pageSize?: number | undefined): Observable<SearchResultOfArchivedCombat> {
        let url_ = this.baseUrl + "/game/team/characters/{characterGuid}/combats/archived?";
        if (characterGuid === undefined || characterGuid === null)
            throw new Error("The parameter 'characterGuid' must be defined.");
        url_ = url_.replace("{characterGuid}", encodeURIComponent("" + characterGuid));
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchArchivedCombats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchArchivedCombats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SearchResultOfArchivedCombat>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SearchResultOfArchivedCombat>;
        }));
    }

    protected processSearchArchivedCombats(response: HttpResponseBase): Observable<SearchResultOfArchivedCombat> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchResultOfArchivedCombat.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Search archived combats history
     * @param pageNumber (optional) The page number
     * @param pageSize (optional) The page size
     */
    searchArchivedCombatHistory(characterGuid: string, combatGuid: string, pageNumber?: number | undefined, pageSize?: number | undefined): Observable<SearchResultOfCombatHistoryEntry> {
        let url_ = this.baseUrl + "/game/team/characters/{characterGuid}/combats/archived/{combatGuid}/history?";
        if (characterGuid === undefined || characterGuid === null)
            throw new Error("The parameter 'characterGuid' must be defined.");
        url_ = url_.replace("{characterGuid}", encodeURIComponent("" + characterGuid));
        if (combatGuid === undefined || combatGuid === null)
            throw new Error("The parameter 'combatGuid' must be defined.");
        url_ = url_.replace("{combatGuid}", encodeURIComponent("" + combatGuid));
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchArchivedCombatHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchArchivedCombatHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SearchResultOfCombatHistoryEntry>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SearchResultOfCombatHistoryEntry>;
        }));
    }

    protected processSearchArchivedCombatHistory(response: HttpResponseBase): Observable<SearchResultOfCombatHistoryEntry> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchResultOfCombatHistoryEntry.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CombatsInPreparationApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7056";
    }

    /**
     * Set combat in preparation options
     * @param value (optional) 
     */
    setCombatInPreparationAccessibility(characterGuid: string, combatGuid: string, side: CombatSide, value?: CombatFormationAccessibility | undefined): Observable<void> {
        let url_ = this.baseUrl + "/game/team/characters/{characterGuid}/combats/preparation/{combatGuid}/{side}/options/accessibility?";
        if (characterGuid === undefined || characterGuid === null)
            throw new Error("The parameter 'characterGuid' must be defined.");
        url_ = url_.replace("{characterGuid}", encodeURIComponent("" + characterGuid));
        if (combatGuid === undefined || combatGuid === null)
            throw new Error("The parameter 'combatGuid' must be defined.");
        url_ = url_.replace("{combatGuid}", encodeURIComponent("" + combatGuid));
        if (side === undefined || side === null)
            throw new Error("The parameter 'side' must be defined.");
        url_ = url_.replace("{side}", encodeURIComponent("" + side));
        if (value === null)
            throw new Error("The parameter 'value' cannot be null.");
        else if (value !== undefined)
            url_ += "value=" + encodeURIComponent("" + value) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetCombatInPreparationAccessibility(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetCombatInPreparationAccessibility(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetCombatInPreparationAccessibility(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class GameApiStatusApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7056";
    }

    /**
     * Ping
     */
    ping(): Observable<void> {
        let url_ = this.baseUrl + "/game/status/ping";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPing(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPing(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class GameContentApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7056";
    }

    /**
     * Get character class
     */
    getCharacterClass(characterClassId: string): Observable<CharacterClass> {
        let url_ = this.baseUrl + "/game/content/characters/classes/{characterClassId}";
        if (characterClassId === undefined || characterClassId === null)
            throw new Error("The parameter 'characterClassId' must be defined.");
        url_ = url_.replace("{characterClassId}", encodeURIComponent("" + characterClassId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCharacterClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCharacterClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CharacterClass>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CharacterClass>;
        }));
    }

    protected processGetCharacterClass(response: HttpResponseBase): Observable<CharacterClass> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CharacterClass.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get item
     */
    getItem(itemId: string): Observable<Item> {
        let url_ = this.baseUrl + "/game/content/items/{itemId}";
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Item>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Item>;
        }));
    }

    protected processGetItem(response: HttpResponseBase): Observable<Item> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Item.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get location
     */
    getLocation(locationId: string): Observable<Location> {
        let url_ = this.baseUrl + "/game/content/locations/{locationId}";
        if (locationId === undefined || locationId === null)
            throw new Error("The parameter 'locationId' must be defined.");
        url_ = url_.replace("{locationId}", encodeURIComponent("" + locationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Location>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Location>;
        }));
    }

    protected processGetLocation(response: HttpResponseBase): Observable<Location> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Location.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get job
     */
    getJob(jobId: string): Observable<Job> {
        let url_ = this.baseUrl + "/game/content/jobs/{jobId}";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJob(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Job>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Job>;
        }));
    }

    protected processGetJob(response: HttpResponseBase): Observable<Job> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Job.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get static object
     */
    getHarvestable(staticObjectId: string): Observable<StaticObject> {
        let url_ = this.baseUrl + "/game/content/static-objects/{staticObjectId}";
        if (staticObjectId === undefined || staticObjectId === null)
            throw new Error("The parameter 'staticObjectId' must be defined.");
        url_ = url_.replace("{staticObjectId}", encodeURIComponent("" + staticObjectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHarvestable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHarvestable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaticObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaticObject>;
        }));
    }

    protected processGetHarvestable(response: HttpResponseBase): Observable<StaticObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaticObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class GameApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7056";
    }

    /**
     * Get game settings
     */
    getGameSettings(): Observable<GameSettings> {
        let url_ = this.baseUrl + "/game/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGameSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGameSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GameSettings>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GameSettings>;
        }));
    }

    protected processGetGameSettings(response: HttpResponseBase): Observable<GameSettings> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameSettings.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get game state
     */
    getGameState(): Observable<GameState> {
        let url_ = this.baseUrl + "/game/state";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGameState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGameState(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GameState>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GameState>;
        }));
    }

    protected processGetGameState(response: HttpResponseBase): Observable<GameState> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameState.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class JobsHarvestApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7056";
    }

    /**
     * Get harvestables
     */
    getHarvestables(characterGuid: string): Observable<HarvestableEntity[]> {
        let url_ = this.baseUrl + "/game/team/characters/{characterGuid}/jobs/harvestables";
        if (characterGuid === undefined || characterGuid === null)
            throw new Error("The parameter 'characterGuid' must be defined.");
        url_ = url_.replace("{characterGuid}", encodeURIComponent("" + characterGuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHarvestables(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHarvestables(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HarvestableEntity[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HarvestableEntity[]>;
        }));
    }

    protected processGetHarvestables(response: HttpResponseBase): Observable<HarvestableEntity[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HarvestableEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Harvest
     */
    harvest(characterGuid: string, entityGuid: string, harvestName: string): Observable<void> {
        let url_ = this.baseUrl + "/game/team/characters/{characterGuid}/jobs/harvestables/{entityGuid}/{harvestName}";
        if (characterGuid === undefined || characterGuid === null)
            throw new Error("The parameter 'characterGuid' must be defined.");
        url_ = url_.replace("{characterGuid}", encodeURIComponent("" + characterGuid));
        if (entityGuid === undefined || entityGuid === null)
            throw new Error("The parameter 'entityGuid' must be defined.");
        url_ = url_.replace("{entityGuid}", encodeURIComponent("" + entityGuid));
        if (harvestName === undefined || harvestName === null)
            throw new Error("The parameter 'harvestName' must be defined.");
        url_ = url_.replace("{harvestName}", encodeURIComponent("" + harvestName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHarvest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHarvest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processHarvest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LocationsApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7056";
    }

    /**
     * Get accessible locations
     */
    getAccessibleLocations(characterGuid: string): Observable<LocationWithAccess[]> {
        let url_ = this.baseUrl + "/game/team/characters/{characterGuid}/locations";
        if (characterGuid === undefined || characterGuid === null)
            throw new Error("The parameter 'characterGuid' must be defined.");
        url_ = url_.replace("{characterGuid}", encodeURIComponent("" + characterGuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccessibleLocations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccessibleLocations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LocationWithAccess[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LocationWithAccess[]>;
        }));
    }

    protected processGetAccessibleLocations(response: HttpResponseBase): Observable<LocationWithAccess[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LocationWithAccess.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Move to location
     */
    moveToLocation(characterGuid: string, locationGuid: string): Observable<void> {
        let url_ = this.baseUrl + "/game/team/characters/{characterGuid}/locations/{locationGuid}";
        if (characterGuid === undefined || characterGuid === null)
            throw new Error("The parameter 'characterGuid' must be defined.");
        url_ = url_.replace("{characterGuid}", encodeURIComponent("" + characterGuid));
        if (locationGuid === undefined || locationGuid === null)
            throw new Error("The parameter 'locationGuid' must be defined.");
        url_ = url_.replace("{locationGuid}", encodeURIComponent("" + locationGuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveToLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveToLocation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMoveToLocation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PveApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7056";
    }

    /**
     * Get monsters
     */
    getMonsters(characterGuid: string): Observable<MonsterGroup[]> {
        let url_ = this.baseUrl + "/game/team/characters/{characterGuid}/pve/monsters";
        if (characterGuid === undefined || characterGuid === null)
            throw new Error("The parameter 'characterGuid' must be defined.");
        url_ = url_.replace("{characterGuid}", encodeURIComponent("" + characterGuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMonsters(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMonsters(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MonsterGroup[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MonsterGroup[]>;
        }));
    }

    protected processGetMonsters(response: HttpResponseBase): Observable<MonsterGroup[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MonsterGroup.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Attack monsters
     */
    attackMonsters(characterGuid: string, groupId: string): Observable<void> {
        let url_ = this.baseUrl + "/game/team/characters/{characterGuid}/pve/monsters/{groupId}";
        if (characterGuid === undefined || characterGuid === null)
            throw new Error("The parameter 'characterGuid' must be defined.");
        url_ = url_.replace("{characterGuid}", encodeURIComponent("" + characterGuid));
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAttackMonsters(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAttackMonsters(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAttackMonsters(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Join combat
     */
    joinCombat(characterGuid: string, monsterGroupGuid: string): Observable<void> {
        let url_ = this.baseUrl + "/game/team/characters/{characterGuid}/pve/{monsterGroupGuid}/join";
        if (characterGuid === undefined || characterGuid === null)
            throw new Error("The parameter 'characterGuid' must be defined.");
        url_ = url_.replace("{characterGuid}", encodeURIComponent("" + characterGuid));
        if (monsterGroupGuid === undefined || monsterGroupGuid === null)
            throw new Error("The parameter 'monsterGroupGuid' must be defined.");
        url_ = url_.replace("{monsterGroupGuid}", encodeURIComponent("" + monsterGroupGuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processJoinCombat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processJoinCombat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processJoinCombat(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TeamApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7056";
    }

    /**
     * Get team
     */
    getTeam(): Observable<Team> {
        let url_ = this.baseUrl + "/game/team";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeam(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeam(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Team>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Team>;
        }));
    }

    protected processGetTeam(response: HttpResponseBase): Observable<Team> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Team.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

/** Character */
export class TeamCharacter implements ITeamCharacter {
    /** The unique ID of the character
             */
    id!: string;
    /** The name of the character
             */
    name!: string;
    /** The class of the character
             */
    class!: CharacterClassMinimal;
    /** The health of the character
             */
    health!: number;
    /** The health of the character
             */
    maxHealth!: number;
    /** The progression of the character
             */
    progression!: ProgressionBarMinimal;
    /** The current location of the character
             */
    location!: LocationMinimal;
    /** The inventory of the character
             */
    inventory!: Inventory;
    /** The jobs of the character
             */
    jobs!: JobInstance[];
    /** The interaction being performed by the character
             */
    ongoingAction?: Action | undefined;
    /** The action that the character has planned for the next tick
             */
    plannedAction?: Action | undefined;

    constructor(data?: ITeamCharacter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.class = new CharacterClassMinimal();
            this.progression = new ProgressionBarMinimal();
            this.location = new LocationMinimal();
            this.inventory = new Inventory();
            this.jobs = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.class = _data["class"] ? CharacterClassMinimal.fromJS(_data["class"]) : new CharacterClassMinimal();
            this.health = _data["health"];
            this.maxHealth = _data["maxHealth"];
            this.progression = _data["progression"] ? ProgressionBarMinimal.fromJS(_data["progression"]) : new ProgressionBarMinimal();
            this.location = _data["location"] ? LocationMinimal.fromJS(_data["location"]) : new LocationMinimal();
            this.inventory = _data["inventory"] ? Inventory.fromJS(_data["inventory"]) : new Inventory();
            if (Array.isArray(_data["jobs"])) {
                this.jobs = [] as any;
                for (let item of _data["jobs"])
                    this.jobs!.push(JobInstance.fromJS(item));
            }
            this.ongoingAction = _data["ongoingAction"] ? Action.fromJS(_data["ongoingAction"]) : <any>undefined;
            this.plannedAction = _data["plannedAction"] ? Action.fromJS(_data["plannedAction"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TeamCharacter {
        data = typeof data === 'object' ? data : {};
        let result = new TeamCharacter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["class"] = this.class ? this.class.toJSON() : <any>undefined;
        data["health"] = this.health;
        data["maxHealth"] = this.maxHealth;
        data["progression"] = this.progression ? this.progression.toJSON() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["inventory"] = this.inventory ? this.inventory.toJSON() : <any>undefined;
        if (Array.isArray(this.jobs)) {
            data["jobs"] = [];
            for (let item of this.jobs)
                data["jobs"].push(item.toJSON());
        }
        data["ongoingAction"] = this.ongoingAction ? this.ongoingAction.toJSON() : <any>undefined;
        data["plannedAction"] = this.plannedAction ? this.plannedAction.toJSON() : <any>undefined;
        return data;
    }
}

/** Character */
export interface ITeamCharacter {
    /** The unique ID of the character
             */
    id: string;
    /** The name of the character
             */
    name: string;
    /** The class of the character
             */
    class: CharacterClassMinimal;
    /** The health of the character
             */
    health: number;
    /** The health of the character
             */
    maxHealth: number;
    /** The progression of the character
             */
    progression: ProgressionBarMinimal;
    /** The current location of the character
             */
    location: LocationMinimal;
    /** The inventory of the character
             */
    inventory: Inventory;
    /** The jobs of the character
             */
    jobs: JobInstance[];
    /** The interaction being performed by the character
             */
    ongoingAction?: Action | undefined;
    /** The action that the character has planned for the next tick
             */
    plannedAction?: Action | undefined;
}

/** Character class (minimal) */
export class CharacterClassMinimal implements ICharacterClassMinimal {
    /** The unique ID of the character class
             */
    id!: string;
    /** The name of the character class
             */
    name!: string;

    constructor(data?: ICharacterClassMinimal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CharacterClassMinimal {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterClassMinimal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

/** Character class (minimal) */
export interface ICharacterClassMinimal {
    /** The unique ID of the character class
             */
    id: string;
    /** The name of the character class
             */
    name: string;
}

/** Progression bar (minimal) */
export class ProgressionBarMinimal implements IProgressionBarMinimal {
    /** The level of progression
             */
    level!: number;
    /** The experience acquired
             */
    experience!: number;
    /** The experience required to reach next level. The value is null when Level is the max level.
             */
    nextLevelExperience!: number;

    constructor(data?: IProgressionBarMinimal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.level = _data["level"];
            this.experience = _data["experience"];
            this.nextLevelExperience = _data["nextLevelExperience"];
        }
    }

    static fromJS(data: any): ProgressionBarMinimal {
        data = typeof data === 'object' ? data : {};
        let result = new ProgressionBarMinimal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["experience"] = this.experience;
        data["nextLevelExperience"] = this.nextLevelExperience;
        return data;
    }
}

/** Progression bar (minimal) */
export interface IProgressionBarMinimal {
    /** The level of progression
             */
    level: number;
    /** The experience acquired
             */
    experience: number;
    /** The experience required to reach next level. The value is null when Level is the max level.
             */
    nextLevelExperience: number;
}

/** Map location minimal information */
export class LocationMinimal implements ILocationMinimal {
    /** The unique ID of the location
             */
    id!: string;
    /** The area associated with the location
             */
    area!: MapArea;
    /** The X coordinate associated with the location
             */
    positionX!: number;
    /** The Y coordinate associated with the location
             */
    positionY!: number;

    constructor(data?: ILocationMinimal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.area = new MapArea();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.area = _data["area"] ? MapArea.fromJS(_data["area"]) : new MapArea();
            this.positionX = _data["positionX"];
            this.positionY = _data["positionY"];
        }
    }

    static fromJS(data: any): LocationMinimal {
        data = typeof data === 'object' ? data : {};
        let result = new LocationMinimal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["area"] = this.area ? this.area.toJSON() : <any>undefined;
        data["positionX"] = this.positionX;
        data["positionY"] = this.positionY;
        return data;
    }
}

/** Map location minimal information */
export interface ILocationMinimal {
    /** The unique ID of the location
             */
    id: string;
    /** The area associated with the location
             */
    area: MapArea;
    /** The X coordinate associated with the location
             */
    positionX: number;
    /** The Y coordinate associated with the location
             */
    positionY: number;
}

/** Map area */
export class MapArea implements IMapArea {
    /** The unique ID of the area
             */
    id!: string;
    /** The name of the area
             */
    name!: string;
    /** The level of the area
             */
    level!: number;

    constructor(data?: IMapArea) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.level = _data["level"];
        }
    }

    static fromJS(data: any): MapArea {
        data = typeof data === 'object' ? data : {};
        let result = new MapArea();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["level"] = this.level;
        return data;
    }
}

/** Map area */
export interface IMapArea {
    /** The unique ID of the area
             */
    id: string;
    /** The name of the area
             */
    name: string;
    /** The level of the area
             */
    level: number;
}

/** Inventory */
export class Inventory implements IInventory {
    /** The entries of the inventory
             */
    stacks!: ItemInstanceStack[];
    /** The total weight of the items in the inventory
             */
    weight!: number;

    constructor(data?: IInventory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.stacks = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["stacks"])) {
                this.stacks = [] as any;
                for (let item of _data["stacks"])
                    this.stacks!.push(ItemInstanceStack.fromJS(item));
            }
            this.weight = _data["weight"];
        }
    }

    static fromJS(data: any): Inventory {
        data = typeof data === 'object' ? data : {};
        let result = new Inventory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.stacks)) {
            data["stacks"] = [];
            for (let item of this.stacks)
                data["stacks"].push(item.toJSON());
        }
        data["weight"] = this.weight;
        return data;
    }
}

/** Inventory */
export interface IInventory {
    /** The entries of the inventory
             */
    stacks: ItemInstanceStack[];
    /** The total weight of the items in the inventory
             */
    weight: number;
}

/** Item stack */
export class ItemInstanceStack implements IItemInstanceStack {
    /** The item instance representing this stack
             */
    itemInstance!: ItemInstance;
    /** The number of instances in this stack
             */
    count!: number;

    constructor(data?: IItemInstanceStack) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.itemInstance = new ItemInstance();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemInstance = _data["itemInstance"] ? ItemInstance.fromJS(_data["itemInstance"]) : new ItemInstance();
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): ItemInstanceStack {
        data = typeof data === 'object' ? data : {};
        let result = new ItemInstanceStack();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemInstance"] = this.itemInstance ? this.itemInstance.toJSON() : <any>undefined;
        data["count"] = this.count;
        return data;
    }
}

/** Item stack */
export interface IItemInstanceStack {
    /** The item instance representing this stack
             */
    itemInstance: ItemInstance;
    /** The number of instances in this stack
             */
    count: number;
}

/** Item instance */
export class ItemInstance implements IItemInstance {
    /** The unique ID of this instance
             */
    id!: string;
    /** The unique ID of the item corresponding to this instance
             */
    item!: ItemMinimal;

    constructor(data?: IItemInstance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.item = new ItemMinimal();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.item = _data["item"] ? ItemMinimal.fromJS(_data["item"]) : new ItemMinimal();
        }
    }

    static fromJS(data: any): ItemInstance {
        data = typeof data === 'object' ? data : {};
        let result = new ItemInstance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["item"] = this.item ? this.item.toJSON() : <any>undefined;
        return data;
    }
}

/** Item instance */
export interface IItemInstance {
    /** The unique ID of this instance
             */
    id: string;
    /** The unique ID of the item corresponding to this instance
             */
    item: ItemMinimal;
}

/** Item (minimal) */
export class ItemMinimal implements IItemMinimal {
    /** The unique ID of the item
             */
    id!: string;
    /** The name of the item
             */
    name!: string;
    /** The weight of the item
             */
    weight!: number;

    constructor(data?: IItemMinimal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.weight = _data["weight"];
        }
    }

    static fromJS(data: any): ItemMinimal {
        data = typeof data === 'object' ? data : {};
        let result = new ItemMinimal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["weight"] = this.weight;
        return data;
    }
}

/** Item (minimal) */
export interface IItemMinimal {
    /** The unique ID of the item
             */
    id: string;
    /** The name of the item
             */
    name: string;
    /** The weight of the item
             */
    weight: number;
}

/** Job instance */
export class JobInstance implements IJobInstance {
    /** The job that is instantiated
             */
    job!: JobMinimal;
    /** The progression of the job
             */
    progression!: ProgressionBarMinimal;

    constructor(data?: IJobInstance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.job = new JobMinimal();
            this.progression = new ProgressionBarMinimal();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.job = _data["job"] ? JobMinimal.fromJS(_data["job"]) : new JobMinimal();
            this.progression = _data["progression"] ? ProgressionBarMinimal.fromJS(_data["progression"]) : new ProgressionBarMinimal();
        }
    }

    static fromJS(data: any): JobInstance {
        data = typeof data === 'object' ? data : {};
        let result = new JobInstance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["job"] = this.job ? this.job.toJSON() : <any>undefined;
        data["progression"] = this.progression ? this.progression.toJSON() : <any>undefined;
        return data;
    }
}

/** Job instance */
export interface IJobInstance {
    /** The job that is instantiated
             */
    job: JobMinimal;
    /** The progression of the job
             */
    progression: ProgressionBarMinimal;
}

/** Job (minimal) */
export class JobMinimal implements IJobMinimal {
    /** The unique ID of the job
             */
    id!: string;
    /** The name of the job
             */
    name!: string;

    constructor(data?: IJobMinimal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): JobMinimal {
        data = typeof data === 'object' ? data : {};
        let result = new JobMinimal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

/** Job (minimal) */
export interface IJobMinimal {
    /** The unique ID of the job
             */
    id: string;
    /** The name of the job
             */
    name: string;
}

/** An action performed by a character */
export class Action implements IAction {
    /** The name of the action
             */
    name!: string;

    protected _discriminator: string;

    constructor(data?: IAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Action";
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Action {
        data = typeof data === 'object' ? data : {};
        if (data["$type"] === "move") {
            let result = new MoveAction();
            result.init(data);
            return result;
        }
        if (data["$type"] === "harvest") {
            let result = new HarvestAction();
            result.init(data);
            return result;
        }
        if (data["$type"] === "combat-pve-start") {
            let result = new StartPveCombatAction();
            result.init(data);
            return result;
        }
        if (data["$type"] === "combat-pve-join") {
            let result = new JoinPveCombatAction();
            result.init(data);
            return result;
        }
        let result = new Action();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$type"] = this._discriminator;
        data["name"] = this.name;
        return data;
    }
}

/** An action performed by a character */
export interface IAction {
    /** The name of the action
             */
    name: string;
}

/** Move action */
export class MoveAction extends Action implements IMoveAction {
    /** The location to which the character is moving
             */
    location!: LocationMinimal;

    constructor(data?: IMoveAction) {
        super(data);
        if (!data) {
            this.location = new LocationMinimal();
        }
        this._discriminator = "move";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.location = _data["location"] ? LocationMinimal.fromJS(_data["location"]) : new LocationMinimal();
        }
    }

    static override fromJS(data: any): MoveAction {
        data = typeof data === 'object' ? data : {};
        let result = new MoveAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Move action */
export interface IMoveAction extends IAction {
    /** The location to which the character is moving
             */
    location: LocationMinimal;
}

/** Harvest action */
export class HarvestAction extends Action implements IHarvestAction {
    /** The harvest
             */
    harvest!: HarvestableEntityHarvestMinimal;
    /** The target of the harvest
             */
    target!: StaticObjectInstance;

    constructor(data?: IHarvestAction) {
        super(data);
        if (!data) {
            this.harvest = new HarvestableEntityHarvestMinimal();
            this.target = new StaticObjectInstance();
        }
        this._discriminator = "harvest";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.harvest = _data["harvest"] ? HarvestableEntityHarvestMinimal.fromJS(_data["harvest"]) : new HarvestableEntityHarvestMinimal();
            this.target = _data["target"] ? StaticObjectInstance.fromJS(_data["target"]) : new StaticObjectInstance();
        }
    }

    static override fromJS(data: any): HarvestAction {
        data = typeof data === 'object' ? data : {};
        let result = new HarvestAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["harvest"] = this.harvest ? this.harvest.toJSON() : <any>undefined;
        data["target"] = this.target ? this.target.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Harvest action */
export interface IHarvestAction extends IAction {
    /** The harvest
             */
    harvest: HarvestableEntityHarvestMinimal;
    /** The target of the harvest
             */
    target: StaticObjectInstance;
}

/** Harvestable entity harvest (minimal */
export class HarvestableEntityHarvestMinimal implements IHarvestableEntityHarvestMinimal {
    /** The job providing the harvest
             */
    job!: JobMinimal;
    /** The name of the harvest
             */
    name!: string;
    /** The level of the harvest
             */
    level!: number;
    /** The targets compatible with the harvest
             */
    targets!: StaticObject[];
    /** The expected result of the harvest
             */
    expectedHarvest!: ItemStack[];
    /** The expected experience gain from the harvest
             */
    expectedExperience!: number;

    constructor(data?: IHarvestableEntityHarvestMinimal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.job = new JobMinimal();
            this.targets = [];
            this.expectedHarvest = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.job = _data["job"] ? JobMinimal.fromJS(_data["job"]) : new JobMinimal();
            this.name = _data["name"];
            this.level = _data["level"];
            if (Array.isArray(_data["targets"])) {
                this.targets = [] as any;
                for (let item of _data["targets"])
                    this.targets!.push(StaticObject.fromJS(item));
            }
            if (Array.isArray(_data["expectedHarvest"])) {
                this.expectedHarvest = [] as any;
                for (let item of _data["expectedHarvest"])
                    this.expectedHarvest!.push(ItemStack.fromJS(item));
            }
            this.expectedExperience = _data["expectedExperience"];
        }
    }

    static fromJS(data: any): HarvestableEntityHarvestMinimal {
        data = typeof data === 'object' ? data : {};
        let result = new HarvestableEntityHarvestMinimal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["job"] = this.job ? this.job.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["level"] = this.level;
        if (Array.isArray(this.targets)) {
            data["targets"] = [];
            for (let item of this.targets)
                data["targets"].push(item.toJSON());
        }
        if (Array.isArray(this.expectedHarvest)) {
            data["expectedHarvest"] = [];
            for (let item of this.expectedHarvest)
                data["expectedHarvest"].push(item.toJSON());
        }
        data["expectedExperience"] = this.expectedExperience;
        return data;
    }
}

/** Harvestable entity harvest (minimal */
export interface IHarvestableEntityHarvestMinimal {
    /** The job providing the harvest
             */
    job: JobMinimal;
    /** The name of the harvest
             */
    name: string;
    /** The level of the harvest
             */
    level: number;
    /** The targets compatible with the harvest
             */
    targets: StaticObject[];
    /** The expected result of the harvest
             */
    expectedHarvest: ItemStack[];
    /** The expected experience gain from the harvest
             */
    expectedExperience: number;
}

/** Static object */
export class StaticObject implements IStaticObject {
    /** The unique ID of the static object
             */
    id!: string;
    /** The name of the static object
             */
    name!: string;
    /** The description of the static object
             */
    description?: string | undefined;

    constructor(data?: IStaticObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): StaticObject {
        data = typeof data === 'object' ? data : {};
        let result = new StaticObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

/** Static object */
export interface IStaticObject {
    /** The unique ID of the static object
             */
    id: string;
    /** The name of the static object
             */
    name: string;
    /** The description of the static object
             */
    description?: string | undefined;
}

/** Item stack */
export class ItemStack implements IItemStack {
    /** The item instance representing this stack
             */
    item!: ItemMinimal;
    /** The number of instances in this stack
             */
    count!: number;

    constructor(data?: IItemStack) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.item = new ItemMinimal();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.item = _data["item"] ? ItemMinimal.fromJS(_data["item"]) : new ItemMinimal();
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): ItemStack {
        data = typeof data === 'object' ? data : {};
        let result = new ItemStack();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["item"] = this.item ? this.item.toJSON() : <any>undefined;
        data["count"] = this.count;
        return data;
    }
}

/** Item stack */
export interface IItemStack {
    /** The item instance representing this stack
             */
    item: ItemMinimal;
    /** The number of instances in this stack
             */
    count: number;
}

/** Static object instance */
export class StaticObjectInstance implements IStaticObjectInstance {
    /** The unique ID of the entity
             */
    id!: string;
    /** The static object association with the entity
             */
    staticObject!: StaticObject;

    constructor(data?: IStaticObjectInstance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.staticObject = new StaticObject();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.staticObject = _data["staticObject"] ? StaticObject.fromJS(_data["staticObject"]) : new StaticObject();
        }
    }

    static fromJS(data: any): StaticObjectInstance {
        data = typeof data === 'object' ? data : {};
        let result = new StaticObjectInstance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["staticObject"] = this.staticObject ? this.staticObject.toJSON() : <any>undefined;
        return data;
    }
}

/** Static object instance */
export interface IStaticObjectInstance {
    /** The unique ID of the entity
             */
    id: string;
    /** The static object association with the entity
             */
    staticObject: StaticObject;
}

/** PVE combat action */
export class StartPveCombatAction extends Action implements IStartPveCombatAction {
    /** The group of monsters
             */
    monsterGroup!: MonsterGroupMinimal;

    constructor(data?: IStartPveCombatAction) {
        super(data);
        if (!data) {
            this.monsterGroup = new MonsterGroupMinimal();
        }
        this._discriminator = "combat-pve-start";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.monsterGroup = _data["monsterGroup"] ? MonsterGroupMinimal.fromJS(_data["monsterGroup"]) : new MonsterGroupMinimal();
        }
    }

    static override fromJS(data: any): StartPveCombatAction {
        data = typeof data === 'object' ? data : {};
        let result = new StartPveCombatAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["monsterGroup"] = this.monsterGroup ? this.monsterGroup.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** PVE combat action */
export interface IStartPveCombatAction extends IAction {
    /** The group of monsters
             */
    monsterGroup: MonsterGroupMinimal;
}

/** Monster group (minimal) */
export class MonsterGroupMinimal implements IMonsterGroupMinimal {
    /** The unique ID of the group
             */
    id!: string;
    /** The monsters in the group
             */
    monsters!: MonsterInGroup[];
    /** The expected experience gain if the character defeats the monster group
             */
    expectedExperience!: number;

    constructor(data?: IMonsterGroupMinimal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.monsters = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["monsters"])) {
                this.monsters = [] as any;
                for (let item of _data["monsters"])
                    this.monsters!.push(MonsterInGroup.fromJS(item));
            }
            this.expectedExperience = _data["expectedExperience"];
        }
    }

    static fromJS(data: any): MonsterGroupMinimal {
        data = typeof data === 'object' ? data : {};
        let result = new MonsterGroupMinimal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.monsters)) {
            data["monsters"] = [];
            for (let item of this.monsters)
                data["monsters"].push(item.toJSON());
        }
        data["expectedExperience"] = this.expectedExperience;
        return data;
    }
}

/** Monster group (minimal) */
export interface IMonsterGroupMinimal {
    /** The unique ID of the group
             */
    id: string;
    /** The monsters in the group
             */
    monsters: MonsterInGroup[];
    /** The expected experience gain if the character defeats the monster group
             */
    expectedExperience: number;
}

/** Monster in group */
export class MonsterInGroup implements IMonsterInGroup {
    /** The species of the monster
             */
    species!: MonsterSpecies;
    /** The level of the monster
             */
    level!: number;

    constructor(data?: IMonsterInGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.species = new MonsterSpecies();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.species = _data["species"] ? MonsterSpecies.fromJS(_data["species"]) : new MonsterSpecies();
            this.level = _data["level"];
        }
    }

    static fromJS(data: any): MonsterInGroup {
        data = typeof data === 'object' ? data : {};
        let result = new MonsterInGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["species"] = this.species ? this.species.toJSON() : <any>undefined;
        data["level"] = this.level;
        return data;
    }
}

/** Monster in group */
export interface IMonsterInGroup {
    /** The species of the monster
             */
    species: MonsterSpecies;
    /** The level of the monster
             */
    level: number;
}

/** Monster species */
export class MonsterSpecies implements IMonsterSpecies {
    /** The family of monsters
             */
    family!: MonsterFamily;
    /** The name of the species
             */
    name!: string;
    /** The description of the species
             */
    description?: string | undefined;

    constructor(data?: IMonsterSpecies) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.family = new MonsterFamily();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.family = _data["family"] ? MonsterFamily.fromJS(_data["family"]) : new MonsterFamily();
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): MonsterSpecies {
        data = typeof data === 'object' ? data : {};
        let result = new MonsterSpecies();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["family"] = this.family ? this.family.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

/** Monster species */
export interface IMonsterSpecies {
    /** The family of monsters
             */
    family: MonsterFamily;
    /** The name of the species
             */
    name: string;
    /** The description of the species
             */
    description?: string | undefined;
}

/** Monster family */
export class MonsterFamily implements IMonsterFamily {
    /** The name of the family
             */
    name!: string;
    /** The description of the family
             */
    description?: string | undefined;

    constructor(data?: IMonsterFamily) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): MonsterFamily {
        data = typeof data === 'object' ? data : {};
        let result = new MonsterFamily();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

/** Monster family */
export interface IMonsterFamily {
    /** The name of the family
             */
    name: string;
    /** The description of the family
             */
    description?: string | undefined;
}

/** PVE combat action */
export class JoinPveCombatAction extends Action implements IJoinPveCombatAction {
    /** The group of monsters
             */
    monsterGroup!: MonsterGroupMinimal;
    /** The combat to join
             */
    combat!: CombatInPreparation;

    constructor(data?: IJoinPveCombatAction) {
        super(data);
        if (!data) {
            this.monsterGroup = new MonsterGroupMinimal();
            this.combat = new CombatInPreparation();
        }
        this._discriminator = "combat-pve-join";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.monsterGroup = _data["monsterGroup"] ? MonsterGroupMinimal.fromJS(_data["monsterGroup"]) : new MonsterGroupMinimal();
            this.combat = _data["combat"] ? CombatInPreparation.fromJS(_data["combat"]) : new CombatInPreparation();
        }
    }

    static override fromJS(data: any): JoinPveCombatAction {
        data = typeof data === 'object' ? data : {};
        let result = new JoinPveCombatAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["monsterGroup"] = this.monsterGroup ? this.monsterGroup.toJSON() : <any>undefined;
        data["combat"] = this.combat ? this.combat.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** PVE combat action */
export interface IJoinPveCombatAction extends IAction {
    /** The group of monsters
             */
    monsterGroup: MonsterGroupMinimal;
    /** The combat to join
             */
    combat: CombatInPreparation;
}

/** Combat base */
export abstract class Combat implements ICombat {
    /** The unique ID of the combat instance
             */
    id!: string;

    protected _discriminator: string;

    constructor(data?: ICombat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Combat";
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Combat {
        data = typeof data === 'object' ? data : {};
        if (data["$phase"] === "preparation") {
            let result = new CombatInPreparation();
            result.init(data);
            return result;
        }
        if (data["$phase"] === "ongoing") {
            let result = new OngoingCombat();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'Combat' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$phase"] = this._discriminator;
        data["id"] = this.id;
        return data;
    }
}

/** Combat base */
export interface ICombat {
    /** The unique ID of the combat instance
             */
    id: string;
}

/** Combat in preparation */
export class CombatInPreparation extends Combat implements ICombatInPreparation {
    /** The attackers in the combat instance
             */
    attackers!: EntityMinimal[];
    /** The options of the attacker side
             */
    attackersOptions!: CombatFormationOptions;
    /** The defenders in the combat instance
             */
    defenders!: EntityMinimal[];
    /** The options of the defender side
             */
    defendersOptions!: CombatFormationOptions;

    constructor(data?: ICombatInPreparation) {
        super(data);
        if (!data) {
            this.attackers = [];
            this.attackersOptions = new CombatFormationOptions();
            this.defenders = [];
            this.defendersOptions = new CombatFormationOptions();
        }
        this._discriminator = "preparation";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["attackers"])) {
                this.attackers = [] as any;
                for (let item of _data["attackers"])
                    this.attackers!.push(EntityMinimal.fromJS(item));
            }
            this.attackersOptions = _data["attackersOptions"] ? CombatFormationOptions.fromJS(_data["attackersOptions"]) : new CombatFormationOptions();
            if (Array.isArray(_data["defenders"])) {
                this.defenders = [] as any;
                for (let item of _data["defenders"])
                    this.defenders!.push(EntityMinimal.fromJS(item));
            }
            this.defendersOptions = _data["defendersOptions"] ? CombatFormationOptions.fromJS(_data["defendersOptions"]) : new CombatFormationOptions();
        }
    }

    static override fromJS(data: any): CombatInPreparation {
        data = typeof data === 'object' ? data : {};
        let result = new CombatInPreparation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.attackers)) {
            data["attackers"] = [];
            for (let item of this.attackers)
                data["attackers"].push(item.toJSON());
        }
        data["attackersOptions"] = this.attackersOptions ? this.attackersOptions.toJSON() : <any>undefined;
        if (Array.isArray(this.defenders)) {
            data["defenders"] = [];
            for (let item of this.defenders)
                data["defenders"].push(item.toJSON());
        }
        data["defendersOptions"] = this.defendersOptions ? this.defendersOptions.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Combat in preparation */
export interface ICombatInPreparation extends ICombat {
    /** The attackers in the combat instance
             */
    attackers: EntityMinimal[];
    /** The options of the attacker side
             */
    attackersOptions: CombatFormationOptions;
    /** The defenders in the combat instance
             */
    defenders: EntityMinimal[];
    /** The options of the defender side
             */
    defendersOptions: CombatFormationOptions;
}

/** Entity (minimal) */
export class EntityMinimal implements IEntityMinimal {
    /** The unique ID of the entity
             */
    id!: string;
    /** The name of the entity
             */
    name!: string;

    constructor(data?: IEntityMinimal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EntityMinimal {
        data = typeof data === 'object' ? data : {};
        let result = new EntityMinimal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

/** Entity (minimal) */
export interface IEntityMinimal {
    /** The unique ID of the entity
             */
    id: string;
    /** The name of the entity
             */
    name: string;
}

/** Combat formation options */
export class CombatFormationOptions implements ICombatFormationOptions {
    /** The accessibility of the combat formation
             */
    accessibility!: CombatFormationAccessibility;
    /** The max number of entities in the formation
             */
    slots!: number;

    constructor(data?: ICombatFormationOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessibility = _data["accessibility"];
            this.slots = _data["slots"];
        }
    }

    static fromJS(data: any): CombatFormationOptions {
        data = typeof data === 'object' ? data : {};
        let result = new CombatFormationOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessibility"] = this.accessibility;
        data["slots"] = this.slots;
        return data;
    }
}

/** Combat formation options */
export interface ICombatFormationOptions {
    /** The accessibility of the combat formation
             */
    accessibility: CombatFormationAccessibility;
    /** The max number of entities in the formation
             */
    slots: number;
}

export enum CombatFormationAccessibility {
    Everyone = "everyone",
    TeamOnly = "teamOnly",
}

/** Combat instance */
export class OngoingCombat extends Combat implements IOngoingCombat {
    /** The current turn of the combat instance
             */
    turn!: number;
    /** The attackers in the combat instance
             */
    attackers!: CombatEntity[];
    /** The defenders in the combat instance
             */
    defenders!: CombatEntity[];

    constructor(data?: IOngoingCombat) {
        super(data);
        if (!data) {
            this.attackers = [];
            this.defenders = [];
        }
        this._discriminator = "ongoing";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.turn = _data["turn"];
            if (Array.isArray(_data["attackers"])) {
                this.attackers = [] as any;
                for (let item of _data["attackers"])
                    this.attackers!.push(CombatEntity.fromJS(item));
            }
            if (Array.isArray(_data["defenders"])) {
                this.defenders = [] as any;
                for (let item of _data["defenders"])
                    this.defenders!.push(CombatEntity.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): OngoingCombat {
        data = typeof data === 'object' ? data : {};
        let result = new OngoingCombat();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["turn"] = this.turn;
        if (Array.isArray(this.attackers)) {
            data["attackers"] = [];
            for (let item of this.attackers)
                data["attackers"].push(item.toJSON());
        }
        if (Array.isArray(this.defenders)) {
            data["defenders"] = [];
            for (let item of this.defenders)
                data["defenders"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Combat instance */
export interface IOngoingCombat extends ICombat {
    /** The current turn of the combat instance
             */
    turn: number;
    /** The attackers in the combat instance
             */
    attackers: CombatEntity[];
    /** The defenders in the combat instance
             */
    defenders: CombatEntity[];
}

/** Entity in combat */
export class CombatEntity extends EntityMinimal implements ICombatEntity {
    /** The level of the character
             */
    level!: number;
    /** The health of the entity
             */
    health!: number;
    /** The max health of the entity
             */
    maxHealth!: number;

    constructor(data?: ICombatEntity) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.level = _data["level"];
            this.health = _data["health"];
            this.maxHealth = _data["maxHealth"];
        }
    }

    static override fromJS(data: any): CombatEntity {
        data = typeof data === 'object' ? data : {};
        let result = new CombatEntity();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["health"] = this.health;
        data["maxHealth"] = this.maxHealth;
        super.toJSON(data);
        return data;
    }
}

/** Entity in combat */
export interface ICombatEntity extends IEntityMinimal {
    /** The level of the character
             */
    level: number;
    /** The health of the entity
             */
    health: number;
    /** The max health of the entity
             */
    maxHealth: number;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

/** Character creation options */
export class CreateCharacterRequest implements ICreateCharacterRequest {
    /** The name of the character
             */
    name!: string;
    /** The class of the character
             */
    classId!: string;

    constructor(data?: ICreateCharacterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.classId = _data["classId"];
        }
    }

    static fromJS(data: any): CreateCharacterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCharacterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["classId"] = this.classId;
        return data;
    }
}

/** Character creation options */
export interface ICreateCharacterRequest {
    /** The name of the character
             */
    name: string;
    /** The class of the character
             */
    classId: string;
}

/** Search result */
export class SearchResultOfCharacterHistoryEntry implements ISearchResultOfCharacterHistoryEntry {
    /** The items found by the query
             */
    items!: CharacterHistoryEntry[];
    /** The page number corresponding to the results that have been selected
             */
    pageNumber!: number;
    /** The page size used by the search
             */
    pageSize!: number;
    /** The total number of items matching the query
             */
    totalItemsCount!: number;
    /** The total number of pages
             */
    totalPagesCount!: number;

    constructor(data?: ISearchResultOfCharacterHistoryEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CharacterHistoryEntry.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.totalItemsCount = _data["totalItemsCount"];
            this.totalPagesCount = _data["totalPagesCount"];
        }
    }

    static fromJS(data: any): SearchResultOfCharacterHistoryEntry {
        data = typeof data === 'object' ? data : {};
        let result = new SearchResultOfCharacterHistoryEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalItemsCount"] = this.totalItemsCount;
        data["totalPagesCount"] = this.totalPagesCount;
        return data;
    }
}

/** Search result */
export interface ISearchResultOfCharacterHistoryEntry {
    /** The items found by the query
             */
    items: CharacterHistoryEntry[];
    /** The page number corresponding to the results that have been selected
             */
    pageNumber: number;
    /** The page size used by the search
             */
    pageSize: number;
    /** The total number of items matching the query
             */
    totalItemsCount: number;
    /** The total number of pages
             */
    totalPagesCount: number;
}

/** Character history entry */
export class CharacterHistoryEntry implements ICharacterHistoryEntry {
    /** The tick at which the event happened
             */
    tick!: number;

    protected _discriminator: string;

    constructor(data?: ICharacterHistoryEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "CharacterHistoryEntry";
    }

    init(_data?: any) {
        if (_data) {
            this.tick = _data["tick"];
        }
    }

    static fromJS(data: any): CharacterHistoryEntry {
        data = typeof data === 'object' ? data : {};
        if (data["$type"] === "created") {
            let result = new CharacterCreatedHistoryEntry();
            result.init(data);
            return result;
        }
        if (data["$type"] === "deleted") {
            let result = new CharacterDeletedHistoryEntry();
            result.init(data);
            return result;
        }
        if (data["$type"] === "teleported") {
            let result = new CharacterTeleporteLocationHistoryEntry();
            result.init(data);
            return result;
        }
        if (data["$type"] === "moved") {
            let result = new CharacterMoveLocationHistoryEntry();
            result.init(data);
            return result;
        }
        if (data["$type"] === "inventory-changed") {
            let result = new CharacterInventoryChangedHistoryEntry();
            result.init(data);
            return result;
        }
        if (data["$type"] === "job-learned") {
            let result = new CharacterLearnedJobHistoryEntry();
            result.init(data);
            return result;
        }
        if (data["$type"] === "job-gained-experience") {
            let result = new CharacterJobGainedExperienceHistoryEntry();
            result.init(data);
            return result;
        }
        if (data["$type"] === "job-leveled-up") {
            let result = new CharacterJobLeveledUpHistoryEntry();
            result.init(data);
            return result;
        }
        if (data["$type"] === "combat-preparation-started") {
            let result = new CharacterStartedCombatPreparationHistoryEntry();
            result.init(data);
            return result;
        }
        if (data["$type"] === "combat-started") {
            let result = new CharacterCombatStartedHistoryEntry();
            result.init(data);
            return result;
        }
        if (data["$type"] === "combat-ended") {
            let result = new CharacterCombatEndedHistoryEntry();
            result.init(data);
            return result;
        }
        let result = new CharacterHistoryEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$type"] = this._discriminator;
        data["tick"] = this.tick;
        return data;
    }
}

/** Character history entry */
export interface ICharacterHistoryEntry {
    /** The tick at which the event happened
             */
    tick: number;
}

/** Character created history entry */
export class CharacterCreatedHistoryEntry extends CharacterHistoryEntry implements ICharacterCreatedHistoryEntry {

    constructor(data?: ICharacterCreatedHistoryEntry) {
        super(data);
        this._discriminator = "created";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CharacterCreatedHistoryEntry {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterCreatedHistoryEntry();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Character created history entry */
export interface ICharacterCreatedHistoryEntry extends ICharacterHistoryEntry {
}

/** Character deleted history entry */
export class CharacterDeletedHistoryEntry extends CharacterHistoryEntry implements ICharacterDeletedHistoryEntry {

    constructor(data?: ICharacterDeletedHistoryEntry) {
        super(data);
        this._discriminator = "deleted";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CharacterDeletedHistoryEntry {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterDeletedHistoryEntry();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Character deleted history entry */
export interface ICharacterDeletedHistoryEntry extends ICharacterHistoryEntry {
}

/** Character teleported to location history entry */
export class CharacterTeleporteLocationHistoryEntry extends CharacterHistoryEntry implements ICharacterTeleporteLocationHistoryEntry {
    /** The unique ID of the old location
             */
    oldLocationId!: string;
    /** The X position of the old location
             */
    oldLocationPositionX!: number;
    /** The Y position of the old location
             */
    oldLocationPositionY!: number;
    /** The unique ID of the area of the old location
             */
    oldLocationAreaId!: string;
    /** The name of the area of the old location
             */
    oldLocationAreaName!: string;
    /** The unique ID of the new location
             */
    newLocationId!: string;
    /** The X position of the new location
             */
    newLocationPositionX!: number;
    /** The Y position of the new location
             */
    newLocationPositionY!: number;
    /** The unique ID of the area of the new location
             */
    newLocationAreaId!: string;
    /** The name of the area of the new location
             */
    newLocationAreaName!: string;

    constructor(data?: ICharacterTeleporteLocationHistoryEntry) {
        super(data);
        this._discriminator = "teleported";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.oldLocationId = _data["oldLocationId"];
            this.oldLocationPositionX = _data["oldLocationPositionX"];
            this.oldLocationPositionY = _data["oldLocationPositionY"];
            this.oldLocationAreaId = _data["oldLocationAreaId"];
            this.oldLocationAreaName = _data["oldLocationAreaName"];
            this.newLocationId = _data["newLocationId"];
            this.newLocationPositionX = _data["newLocationPositionX"];
            this.newLocationPositionY = _data["newLocationPositionY"];
            this.newLocationAreaId = _data["newLocationAreaId"];
            this.newLocationAreaName = _data["newLocationAreaName"];
        }
    }

    static override fromJS(data: any): CharacterTeleporteLocationHistoryEntry {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterTeleporteLocationHistoryEntry();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldLocationId"] = this.oldLocationId;
        data["oldLocationPositionX"] = this.oldLocationPositionX;
        data["oldLocationPositionY"] = this.oldLocationPositionY;
        data["oldLocationAreaId"] = this.oldLocationAreaId;
        data["oldLocationAreaName"] = this.oldLocationAreaName;
        data["newLocationId"] = this.newLocationId;
        data["newLocationPositionX"] = this.newLocationPositionX;
        data["newLocationPositionY"] = this.newLocationPositionY;
        data["newLocationAreaId"] = this.newLocationAreaId;
        data["newLocationAreaName"] = this.newLocationAreaName;
        super.toJSON(data);
        return data;
    }
}

/** Character teleported to location history entry */
export interface ICharacterTeleporteLocationHistoryEntry extends ICharacterHistoryEntry {
    /** The unique ID of the old location
             */
    oldLocationId: string;
    /** The X position of the old location
             */
    oldLocationPositionX: number;
    /** The Y position of the old location
             */
    oldLocationPositionY: number;
    /** The unique ID of the area of the old location
             */
    oldLocationAreaId: string;
    /** The name of the area of the old location
             */
    oldLocationAreaName: string;
    /** The unique ID of the new location
             */
    newLocationId: string;
    /** The X position of the new location
             */
    newLocationPositionX: number;
    /** The Y position of the new location
             */
    newLocationPositionY: number;
    /** The unique ID of the area of the new location
             */
    newLocationAreaId: string;
    /** The name of the area of the new location
             */
    newLocationAreaName: string;
}

/** Character moved to location history entry */
export class CharacterMoveLocationHistoryEntry extends CharacterHistoryEntry implements ICharacterMoveLocationHistoryEntry {
    /** The unique ID of the old location
             */
    oldLocationId!: string;
    /** The X position of the old location
             */
    oldLocationPositionX!: number;
    /** The Y position of the old location
             */
    oldLocationPositionY!: number;
    /** The unique ID of the area of the old location
             */
    oldLocationAreaId!: string;
    /** The name of the area of the old location
             */
    oldLocationAreaName!: string;
    /** The unique ID of the new location
             */
    newLocationId!: string;
    /** The X position of the new location
             */
    newLocationPositionX!: number;
    /** The Y position of the new location
             */
    newLocationPositionY!: number;
    /** The unique ID of the area of the new location
             */
    newLocationAreaId!: string;
    /** The name of the area of the new location
             */
    newLocationAreaName!: string;

    constructor(data?: ICharacterMoveLocationHistoryEntry) {
        super(data);
        this._discriminator = "moved";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.oldLocationId = _data["oldLocationId"];
            this.oldLocationPositionX = _data["oldLocationPositionX"];
            this.oldLocationPositionY = _data["oldLocationPositionY"];
            this.oldLocationAreaId = _data["oldLocationAreaId"];
            this.oldLocationAreaName = _data["oldLocationAreaName"];
            this.newLocationId = _data["newLocationId"];
            this.newLocationPositionX = _data["newLocationPositionX"];
            this.newLocationPositionY = _data["newLocationPositionY"];
            this.newLocationAreaId = _data["newLocationAreaId"];
            this.newLocationAreaName = _data["newLocationAreaName"];
        }
    }

    static override fromJS(data: any): CharacterMoveLocationHistoryEntry {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterMoveLocationHistoryEntry();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldLocationId"] = this.oldLocationId;
        data["oldLocationPositionX"] = this.oldLocationPositionX;
        data["oldLocationPositionY"] = this.oldLocationPositionY;
        data["oldLocationAreaId"] = this.oldLocationAreaId;
        data["oldLocationAreaName"] = this.oldLocationAreaName;
        data["newLocationId"] = this.newLocationId;
        data["newLocationPositionX"] = this.newLocationPositionX;
        data["newLocationPositionY"] = this.newLocationPositionY;
        data["newLocationAreaId"] = this.newLocationAreaId;
        data["newLocationAreaName"] = this.newLocationAreaName;
        super.toJSON(data);
        return data;
    }
}

/** Character moved to location history entry */
export interface ICharacterMoveLocationHistoryEntry extends ICharacterHistoryEntry {
    /** The unique ID of the old location
             */
    oldLocationId: string;
    /** The X position of the old location
             */
    oldLocationPositionX: number;
    /** The Y position of the old location
             */
    oldLocationPositionY: number;
    /** The unique ID of the area of the old location
             */
    oldLocationAreaId: string;
    /** The name of the area of the old location
             */
    oldLocationAreaName: string;
    /** The unique ID of the new location
             */
    newLocationId: string;
    /** The X position of the new location
             */
    newLocationPositionX: number;
    /** The Y position of the new location
             */
    newLocationPositionY: number;
    /** The unique ID of the area of the new location
             */
    newLocationAreaId: string;
    /** The name of the area of the new location
             */
    newLocationAreaName: string;
}

/** Character inventory changed history entry */
export class CharacterInventoryChangedHistoryEntry extends CharacterHistoryEntry implements ICharacterInventoryChangedHistoryEntry {
    /** The
             */
    itemInstanceId!: string;
    /** The
             */
    itemId!: string;
    /** The
             */
    itemName!: string;
    /** The
             */
    oldCount!: number;
    /** The
             */
    newCount!: number;

    constructor(data?: ICharacterInventoryChangedHistoryEntry) {
        super(data);
        this._discriminator = "inventory-changed";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.itemInstanceId = _data["itemInstanceId"];
            this.itemId = _data["itemId"];
            this.itemName = _data["itemName"];
            this.oldCount = _data["oldCount"];
            this.newCount = _data["newCount"];
        }
    }

    static override fromJS(data: any): CharacterInventoryChangedHistoryEntry {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterInventoryChangedHistoryEntry();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemInstanceId"] = this.itemInstanceId;
        data["itemId"] = this.itemId;
        data["itemName"] = this.itemName;
        data["oldCount"] = this.oldCount;
        data["newCount"] = this.newCount;
        super.toJSON(data);
        return data;
    }
}

/** Character inventory changed history entry */
export interface ICharacterInventoryChangedHistoryEntry extends ICharacterHistoryEntry {
    /** The
             */
    itemInstanceId: string;
    /** The
             */
    itemId: string;
    /** The
             */
    itemName: string;
    /** The
             */
    oldCount: number;
    /** The
             */
    newCount: number;
}

/** Character learned job history entry */
export class CharacterLearnedJobHistoryEntry extends CharacterHistoryEntry implements ICharacterLearnedJobHistoryEntry {
    /** The unique ID of the job
             */
    jobId!: string;
    /** The name of the job
             */
    jobName!: string;

    constructor(data?: ICharacterLearnedJobHistoryEntry) {
        super(data);
        this._discriminator = "job-learned";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.jobId = _data["jobId"];
            this.jobName = _data["jobName"];
        }
    }

    static override fromJS(data: any): CharacterLearnedJobHistoryEntry {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterLearnedJobHistoryEntry();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        data["jobName"] = this.jobName;
        super.toJSON(data);
        return data;
    }
}

/** Character learned job history entry */
export interface ICharacterLearnedJobHistoryEntry extends ICharacterHistoryEntry {
    /** The unique ID of the job
             */
    jobId: string;
    /** The name of the job
             */
    jobName: string;
}

/** Character learned job history entry */
export class CharacterJobGainedExperienceHistoryEntry extends CharacterHistoryEntry implements ICharacterJobGainedExperienceHistoryEntry {
    /** The unique ID of the job
             */
    jobId!: string;
    /** The name of the job
             */
    jobName!: string;
    /** The old level of the job
             */
    oldExperience!: number;
    /** The new level of the job
             */
    newExperience!: number;

    constructor(data?: ICharacterJobGainedExperienceHistoryEntry) {
        super(data);
        this._discriminator = "job-gained-experience";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.jobId = _data["jobId"];
            this.jobName = _data["jobName"];
            this.oldExperience = _data["oldExperience"];
            this.newExperience = _data["newExperience"];
        }
    }

    static override fromJS(data: any): CharacterJobGainedExperienceHistoryEntry {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterJobGainedExperienceHistoryEntry();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        data["jobName"] = this.jobName;
        data["oldExperience"] = this.oldExperience;
        data["newExperience"] = this.newExperience;
        super.toJSON(data);
        return data;
    }
}

/** Character learned job history entry */
export interface ICharacterJobGainedExperienceHistoryEntry extends ICharacterHistoryEntry {
    /** The unique ID of the job
             */
    jobId: string;
    /** The name of the job
             */
    jobName: string;
    /** The old level of the job
             */
    oldExperience: number;
    /** The new level of the job
             */
    newExperience: number;
}

/** Character learned job history entry */
export class CharacterJobLeveledUpHistoryEntry extends CharacterHistoryEntry implements ICharacterJobLeveledUpHistoryEntry {
    /** The unique ID of the job
             */
    jobId!: string;
    /** The name of the job
             */
    jobName!: string;
    /** The old level of the job
             */
    oldLevel!: number;
    /** The new level of the job
             */
    newLevel!: number;

    constructor(data?: ICharacterJobLeveledUpHistoryEntry) {
        super(data);
        this._discriminator = "job-leveled-up";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.jobId = _data["jobId"];
            this.jobName = _data["jobName"];
            this.oldLevel = _data["oldLevel"];
            this.newLevel = _data["newLevel"];
        }
    }

    static override fromJS(data: any): CharacterJobLeveledUpHistoryEntry {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterJobLeveledUpHistoryEntry();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        data["jobName"] = this.jobName;
        data["oldLevel"] = this.oldLevel;
        data["newLevel"] = this.newLevel;
        super.toJSON(data);
        return data;
    }
}

/** Character learned job history entry */
export interface ICharacterJobLeveledUpHistoryEntry extends ICharacterHistoryEntry {
    /** The unique ID of the job
             */
    jobId: string;
    /** The name of the job
             */
    jobName: string;
    /** The old level of the job
             */
    oldLevel: number;
    /** The new level of the job
             */
    newLevel: number;
}

/** Character started combat in preparation */
export class CharacterStartedCombatPreparationHistoryEntry extends CharacterHistoryEntry implements ICharacterStartedCombatPreparationHistoryEntry {
    /** The unique ID of the combat instance
             */
    combatInstanceId!: string;
    /** The unique ID of the location of the combat
             */
    locationId!: string;
    /** The unique ID of the area of the location of the combat
             */
    locationAreaId!: string;
    /** The name of the area of the location of the combat
             */
    locationAreaName!: string;
    /** The X position of the location of the combat
             */
    locationPositionX!: number;
    /** The Y position of the location of the combat
             */
    locationPositionY!: number;
    /** The attackers of the combat
             */
    attackers!: CombatEntityInHistoryEntry[];
    /** The defenders of the combat
             */
    defenders!: CombatEntityInHistoryEntry[];

    constructor(data?: ICharacterStartedCombatPreparationHistoryEntry) {
        super(data);
        if (!data) {
            this.attackers = [];
            this.defenders = [];
        }
        this._discriminator = "combat-preparation-started";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.combatInstanceId = _data["combatInstanceId"];
            this.locationId = _data["locationId"];
            this.locationAreaId = _data["locationAreaId"];
            this.locationAreaName = _data["locationAreaName"];
            this.locationPositionX = _data["locationPositionX"];
            this.locationPositionY = _data["locationPositionY"];
            if (Array.isArray(_data["attackers"])) {
                this.attackers = [] as any;
                for (let item of _data["attackers"])
                    this.attackers!.push(CombatEntityInHistoryEntry.fromJS(item));
            }
            if (Array.isArray(_data["defenders"])) {
                this.defenders = [] as any;
                for (let item of _data["defenders"])
                    this.defenders!.push(CombatEntityInHistoryEntry.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): CharacterStartedCombatPreparationHistoryEntry {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterStartedCombatPreparationHistoryEntry();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["combatInstanceId"] = this.combatInstanceId;
        data["locationId"] = this.locationId;
        data["locationAreaId"] = this.locationAreaId;
        data["locationAreaName"] = this.locationAreaName;
        data["locationPositionX"] = this.locationPositionX;
        data["locationPositionY"] = this.locationPositionY;
        if (Array.isArray(this.attackers)) {
            data["attackers"] = [];
            for (let item of this.attackers)
                data["attackers"].push(item.toJSON());
        }
        if (Array.isArray(this.defenders)) {
            data["defenders"] = [];
            for (let item of this.defenders)
                data["defenders"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Character started combat in preparation */
export interface ICharacterStartedCombatPreparationHistoryEntry extends ICharacterHistoryEntry {
    /** The unique ID of the combat instance
             */
    combatInstanceId: string;
    /** The unique ID of the location of the combat
             */
    locationId: string;
    /** The unique ID of the area of the location of the combat
             */
    locationAreaId: string;
    /** The name of the area of the location of the combat
             */
    locationAreaName: string;
    /** The X position of the location of the combat
             */
    locationPositionX: number;
    /** The Y position of the location of the combat
             */
    locationPositionY: number;
    /** The attackers of the combat
             */
    attackers: CombatEntityInHistoryEntry[];
    /** The defenders of the combat
             */
    defenders: CombatEntityInHistoryEntry[];
}

/** Combat entity in history entry */
export class CombatEntityInHistoryEntry implements ICombatEntityInHistoryEntry {
    /** The unique ID of the entity
             */
    id!: string;
    /** The name of the entity
             */
    name!: string;

    constructor(data?: ICombatEntityInHistoryEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CombatEntityInHistoryEntry {
        data = typeof data === 'object' ? data : {};
        let result = new CombatEntityInHistoryEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

/** Combat entity in history entry */
export interface ICombatEntityInHistoryEntry {
    /** The unique ID of the entity
             */
    id: string;
    /** The name of the entity
             */
    name: string;
}

/** Character combat in preparation canceled */
export class CharacterCombatStartedHistoryEntry extends CharacterHistoryEntry implements ICharacterCombatStartedHistoryEntry {
    /** The unique ID of the combat instance
             */
    combatInstanceId!: string;
    /** The unique ID of the location of the combat
             */
    locationId!: string;
    /** The unique ID of the area of the location of the combat
             */
    locationAreaId!: string;
    /** The name of the area of the location of the combat
             */
    locationAreaName!: string;
    /** The X position of the location of the combat
             */
    locationPositionX!: number;
    /** The Y position of the location of the combat
             */
    locationPositionY!: number;
    /** The attackers of the combat
             */
    attackers!: CombatEntityInHistoryEntry[];
    /** The defenders of the combat
             */
    defenders!: CombatEntityInHistoryEntry[];

    constructor(data?: ICharacterCombatStartedHistoryEntry) {
        super(data);
        if (!data) {
            this.attackers = [];
            this.defenders = [];
        }
        this._discriminator = "combat-started";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.combatInstanceId = _data["combatInstanceId"];
            this.locationId = _data["locationId"];
            this.locationAreaId = _data["locationAreaId"];
            this.locationAreaName = _data["locationAreaName"];
            this.locationPositionX = _data["locationPositionX"];
            this.locationPositionY = _data["locationPositionY"];
            if (Array.isArray(_data["attackers"])) {
                this.attackers = [] as any;
                for (let item of _data["attackers"])
                    this.attackers!.push(CombatEntityInHistoryEntry.fromJS(item));
            }
            if (Array.isArray(_data["defenders"])) {
                this.defenders = [] as any;
                for (let item of _data["defenders"])
                    this.defenders!.push(CombatEntityInHistoryEntry.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): CharacterCombatStartedHistoryEntry {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterCombatStartedHistoryEntry();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["combatInstanceId"] = this.combatInstanceId;
        data["locationId"] = this.locationId;
        data["locationAreaId"] = this.locationAreaId;
        data["locationAreaName"] = this.locationAreaName;
        data["locationPositionX"] = this.locationPositionX;
        data["locationPositionY"] = this.locationPositionY;
        if (Array.isArray(this.attackers)) {
            data["attackers"] = [];
            for (let item of this.attackers)
                data["attackers"].push(item.toJSON());
        }
        if (Array.isArray(this.defenders)) {
            data["defenders"] = [];
            for (let item of this.defenders)
                data["defenders"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Character combat in preparation canceled */
export interface ICharacterCombatStartedHistoryEntry extends ICharacterHistoryEntry {
    /** The unique ID of the combat instance
             */
    combatInstanceId: string;
    /** The unique ID of the location of the combat
             */
    locationId: string;
    /** The unique ID of the area of the location of the combat
             */
    locationAreaId: string;
    /** The name of the area of the location of the combat
             */
    locationAreaName: string;
    /** The X position of the location of the combat
             */
    locationPositionX: number;
    /** The Y position of the location of the combat
             */
    locationPositionY: number;
    /** The attackers of the combat
             */
    attackers: CombatEntityInHistoryEntry[];
    /** The defenders of the combat
             */
    defenders: CombatEntityInHistoryEntry[];
}

/** Character combat in preparation canceled */
export class CharacterCombatEndedHistoryEntry extends CharacterHistoryEntry implements ICharacterCombatEndedHistoryEntry {
    /** The unique ID of the combat instance
             */
    combatInstanceId!: string;
    /** The unique ID of the location of the combat
             */
    locationId!: string;
    /** The unique ID of the area of the location of the combat
             */
    locationAreaId!: string;
    /** The name of the area of the location of the combat
             */
    locationAreaName!: string;
    /** The X position of the location of the combat
             */
    locationPositionX!: number;
    /** The Y position of the location of the combat
             */
    locationPositionY!: number;
    /** The attackers of the combat
             */
    attackers!: CombatEntityInHistoryEntry[];
    /** The defenders of the combat
             */
    defenders!: CombatEntityInHistoryEntry[];
    /** The winner of the combat
             */
    winner!: CombatSide;
    /** The number of ticks during which the combat was being played
             */
    duration!: number;

    constructor(data?: ICharacterCombatEndedHistoryEntry) {
        super(data);
        if (!data) {
            this.attackers = [];
            this.defenders = [];
        }
        this._discriminator = "combat-ended";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.combatInstanceId = _data["combatInstanceId"];
            this.locationId = _data["locationId"];
            this.locationAreaId = _data["locationAreaId"];
            this.locationAreaName = _data["locationAreaName"];
            this.locationPositionX = _data["locationPositionX"];
            this.locationPositionY = _data["locationPositionY"];
            if (Array.isArray(_data["attackers"])) {
                this.attackers = [] as any;
                for (let item of _data["attackers"])
                    this.attackers!.push(CombatEntityInHistoryEntry.fromJS(item));
            }
            if (Array.isArray(_data["defenders"])) {
                this.defenders = [] as any;
                for (let item of _data["defenders"])
                    this.defenders!.push(CombatEntityInHistoryEntry.fromJS(item));
            }
            this.winner = _data["winner"];
            this.duration = _data["duration"];
        }
    }

    static override fromJS(data: any): CharacterCombatEndedHistoryEntry {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterCombatEndedHistoryEntry();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["combatInstanceId"] = this.combatInstanceId;
        data["locationId"] = this.locationId;
        data["locationAreaId"] = this.locationAreaId;
        data["locationAreaName"] = this.locationAreaName;
        data["locationPositionX"] = this.locationPositionX;
        data["locationPositionY"] = this.locationPositionY;
        if (Array.isArray(this.attackers)) {
            data["attackers"] = [];
            for (let item of this.attackers)
                data["attackers"].push(item.toJSON());
        }
        if (Array.isArray(this.defenders)) {
            data["defenders"] = [];
            for (let item of this.defenders)
                data["defenders"].push(item.toJSON());
        }
        data["winner"] = this.winner;
        data["duration"] = this.duration;
        super.toJSON(data);
        return data;
    }
}

/** Character combat in preparation canceled */
export interface ICharacterCombatEndedHistoryEntry extends ICharacterHistoryEntry {
    /** The unique ID of the combat instance
             */
    combatInstanceId: string;
    /** The unique ID of the location of the combat
             */
    locationId: string;
    /** The unique ID of the area of the location of the combat
             */
    locationAreaId: string;
    /** The name of the area of the location of the combat
             */
    locationAreaName: string;
    /** The X position of the location of the combat
             */
    locationPositionX: number;
    /** The Y position of the location of the combat
             */
    locationPositionY: number;
    /** The attackers of the combat
             */
    attackers: CombatEntityInHistoryEntry[];
    /** The defenders of the combat
             */
    defenders: CombatEntityInHistoryEntry[];
    /** The winner of the combat
             */
    winner: CombatSide;
    /** The number of ticks during which the combat was being played
             */
    duration: number;
}

export enum CombatSide {
    Attackers = "attackers",
    Defenders = "defenders",
}

/** Search result */
export class SearchResultOfCombatHistoryEntry implements ISearchResultOfCombatHistoryEntry {
    /** The items found by the query
             */
    items!: CombatHistoryEntry[];
    /** The page number corresponding to the results that have been selected
             */
    pageNumber!: number;
    /** The page size used by the search
             */
    pageSize!: number;
    /** The total number of items matching the query
             */
    totalItemsCount!: number;
    /** The total number of pages
             */
    totalPagesCount!: number;

    constructor(data?: ISearchResultOfCombatHistoryEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CombatHistoryEntry.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.totalItemsCount = _data["totalItemsCount"];
            this.totalPagesCount = _data["totalPagesCount"];
        }
    }

    static fromJS(data: any): SearchResultOfCombatHistoryEntry {
        data = typeof data === 'object' ? data : {};
        let result = new SearchResultOfCombatHistoryEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalItemsCount"] = this.totalItemsCount;
        data["totalPagesCount"] = this.totalPagesCount;
        return data;
    }
}

/** Search result */
export interface ISearchResultOfCombatHistoryEntry {
    /** The items found by the query
             */
    items: CombatHistoryEntry[];
    /** The page number corresponding to the results that have been selected
             */
    pageNumber: number;
    /** The page size used by the search
             */
    pageSize: number;
    /** The total number of items matching the query
             */
    totalItemsCount: number;
    /** The total number of pages
             */
    totalPagesCount: number;
}

/** Combat history entry */
export class CombatHistoryEntry implements ICombatHistoryEntry {
    /** The tick at which the event happened
             */
    tick!: number;
    /** The turn at which the event happened
             */
    turn!: number;

    protected _discriminator: string;

    constructor(data?: ICombatHistoryEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "CombatHistoryEntry";
    }

    init(_data?: any) {
        if (_data) {
            this.tick = _data["tick"];
            this.turn = _data["turn"];
        }
    }

    static fromJS(data: any): CombatHistoryEntry {
        data = typeof data === 'object' ? data : {};
        if (data["$type"] === "preparation-started") {
            let result = new CombatPreparationStartedHistoryEntry();
            result.init(data);
            return result;
        }
        if (data["$type"] === "started") {
            let result = new CombatStartedHistoryEntry();
            result.init(data);
            return result;
        }
        if (data["$type"] === "entity-joined") {
            let result = new CombatEntityJoinedHistoryEntry();
            result.init(data);
            return result;
        }
        if (data["$type"] === "entity-left") {
            let result = new CombatEntityLeftHistoryEntry();
            result.init(data);
            return result;
        }
        if (data["$type"] === "entity-attacked") {
            let result = new CombatEntityAttackedHistoryEntry();
            result.init(data);
            return result;
        }
        if (data["$type"] === "entity-died") {
            let result = new CombatEntityDiedHistoryEntry();
            result.init(data);
            return result;
        }
        if (data["$type"] === "ended") {
            let result = new CombatEndedHistoryEntry();
            result.init(data);
            return result;
        }
        let result = new CombatHistoryEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$type"] = this._discriminator;
        data["tick"] = this.tick;
        data["turn"] = this.turn;
        return data;
    }
}

/** Combat history entry */
export interface ICombatHistoryEntry {
    /** The tick at which the event happened
             */
    tick: number;
    /** The turn at which the event happened
             */
    turn: number;
}

/** Combat preparation started history entry */
export class CombatPreparationStartedHistoryEntry extends CombatHistoryEntry implements ICombatPreparationStartedHistoryEntry {

    constructor(data?: ICombatPreparationStartedHistoryEntry) {
        super(data);
        this._discriminator = "preparation-started";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CombatPreparationStartedHistoryEntry {
        data = typeof data === 'object' ? data : {};
        let result = new CombatPreparationStartedHistoryEntry();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Combat preparation started history entry */
export interface ICombatPreparationStartedHistoryEntry extends ICombatHistoryEntry {
}

/** Combat started history entry */
export class CombatStartedHistoryEntry extends CombatHistoryEntry implements ICombatStartedHistoryEntry {

    constructor(data?: ICombatStartedHistoryEntry) {
        super(data);
        this._discriminator = "started";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CombatStartedHistoryEntry {
        data = typeof data === 'object' ? data : {};
        let result = new CombatStartedHistoryEntry();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Combat started history entry */
export interface ICombatStartedHistoryEntry extends ICombatHistoryEntry {
}

/** Combat entity joined history entry */
export class CombatEntityJoinedHistoryEntry extends CombatHistoryEntry implements ICombatEntityJoinedHistoryEntry {
    /** The unique ID of the entity that joined the combat
             */
    entityId!: string;
    /** The name of the entity that joined the combat
             */
    entityName!: string;
    /** The side of the combat joined by the entity
             */
    side!: CombatSide;

    constructor(data?: ICombatEntityJoinedHistoryEntry) {
        super(data);
        this._discriminator = "entity-joined";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.entityId = _data["entityId"];
            this.entityName = _data["entityName"];
            this.side = _data["side"];
        }
    }

    static override fromJS(data: any): CombatEntityJoinedHistoryEntry {
        data = typeof data === 'object' ? data : {};
        let result = new CombatEntityJoinedHistoryEntry();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        data["entityName"] = this.entityName;
        data["side"] = this.side;
        super.toJSON(data);
        return data;
    }
}

/** Combat entity joined history entry */
export interface ICombatEntityJoinedHistoryEntry extends ICombatHistoryEntry {
    /** The unique ID of the entity that joined the combat
             */
    entityId: string;
    /** The name of the entity that joined the combat
             */
    entityName: string;
    /** The side of the combat joined by the entity
             */
    side: CombatSide;
}

/** Combat entity left history entry */
export class CombatEntityLeftHistoryEntry extends CombatHistoryEntry implements ICombatEntityLeftHistoryEntry {
    /** The unique ID of the entity that left the combat
             */
    entityId!: string;
    /** The name of the entity that left the combat
             */
    entityName!: string;
    /** The side of the combat left by the entity
             */
    side!: CombatSide;

    constructor(data?: ICombatEntityLeftHistoryEntry) {
        super(data);
        this._discriminator = "entity-left";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.entityId = _data["entityId"];
            this.entityName = _data["entityName"];
            this.side = _data["side"];
        }
    }

    static override fromJS(data: any): CombatEntityLeftHistoryEntry {
        data = typeof data === 'object' ? data : {};
        let result = new CombatEntityLeftHistoryEntry();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        data["entityName"] = this.entityName;
        data["side"] = this.side;
        super.toJSON(data);
        return data;
    }
}

/** Combat entity left history entry */
export interface ICombatEntityLeftHistoryEntry extends ICombatHistoryEntry {
    /** The unique ID of the entity that left the combat
             */
    entityId: string;
    /** The name of the entity that left the combat
             */
    entityName: string;
    /** The side of the combat left by the entity
             */
    side: CombatSide;
}

/** Combat entity attacked history entry */
export class CombatEntityAttackedHistoryEntry extends CombatHistoryEntry implements ICombatEntityAttackedHistoryEntry {
    /** The unique ID of the entity that attacked
             */
    attackerId!: string;
    /** The name of the entity that attacked
             */
    attackerName!: string;
    /** The unique ID of the entity that was attacked
             */
    targetId!: string;
    /** The name of the entity that was attacked
             */
    targetName!: string;
    /** The damages dealt by the attacker to the target
             */
    damage!: number;

    constructor(data?: ICombatEntityAttackedHistoryEntry) {
        super(data);
        this._discriminator = "entity-attacked";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.attackerId = _data["attackerId"];
            this.attackerName = _data["attackerName"];
            this.targetId = _data["targetId"];
            this.targetName = _data["targetName"];
            this.damage = _data["damage"];
        }
    }

    static override fromJS(data: any): CombatEntityAttackedHistoryEntry {
        data = typeof data === 'object' ? data : {};
        let result = new CombatEntityAttackedHistoryEntry();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attackerId"] = this.attackerId;
        data["attackerName"] = this.attackerName;
        data["targetId"] = this.targetId;
        data["targetName"] = this.targetName;
        data["damage"] = this.damage;
        super.toJSON(data);
        return data;
    }
}

/** Combat entity attacked history entry */
export interface ICombatEntityAttackedHistoryEntry extends ICombatHistoryEntry {
    /** The unique ID of the entity that attacked
             */
    attackerId: string;
    /** The name of the entity that attacked
             */
    attackerName: string;
    /** The unique ID of the entity that was attacked
             */
    targetId: string;
    /** The name of the entity that was attacked
             */
    targetName: string;
    /** The damages dealt by the attacker to the target
             */
    damage: number;
}

/** Combat entity died history entry */
export class CombatEntityDiedHistoryEntry extends CombatHistoryEntry implements ICombatEntityDiedHistoryEntry {
    /** The unique ID of the entity that died
             */
    entityId!: string;
    /** The name of the entity that died
             */
    entityName!: string;
    /** The unique ID of the entity that attacked
             */
    attackerId!: string;
    /** The name of the entity that attacked
             */
    attackerName!: string;

    constructor(data?: ICombatEntityDiedHistoryEntry) {
        super(data);
        this._discriminator = "entity-died";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.entityId = _data["entityId"];
            this.entityName = _data["entityName"];
            this.attackerId = _data["attackerId"];
            this.attackerName = _data["attackerName"];
        }
    }

    static override fromJS(data: any): CombatEntityDiedHistoryEntry {
        data = typeof data === 'object' ? data : {};
        let result = new CombatEntityDiedHistoryEntry();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        data["entityName"] = this.entityName;
        data["attackerId"] = this.attackerId;
        data["attackerName"] = this.attackerName;
        super.toJSON(data);
        return data;
    }
}

/** Combat entity died history entry */
export interface ICombatEntityDiedHistoryEntry extends ICombatHistoryEntry {
    /** The unique ID of the entity that died
             */
    entityId: string;
    /** The name of the entity that died
             */
    entityName: string;
    /** The unique ID of the entity that attacked
             */
    attackerId: string;
    /** The name of the entity that attacked
             */
    attackerName: string;
}

/** Combat ended history entry */
export class CombatEndedHistoryEntry extends CombatHistoryEntry implements ICombatEndedHistoryEntry {
    /** The winner of the combat
             */
    winner!: CombatSide;

    constructor(data?: ICombatEndedHistoryEntry) {
        super(data);
        this._discriminator = "ended";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.winner = _data["winner"];
        }
    }

    static override fromJS(data: any): CombatEndedHistoryEntry {
        data = typeof data === 'object' ? data : {};
        let result = new CombatEndedHistoryEntry();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["winner"] = this.winner;
        super.toJSON(data);
        return data;
    }
}

/** Combat ended history entry */
export interface ICombatEndedHistoryEntry extends ICombatHistoryEntry {
    /** The winner of the combat
             */
    winner: CombatSide;
}

/** Search result */
export class SearchResultOfArchivedCombat implements ISearchResultOfArchivedCombat {
    /** The items found by the query
             */
    items!: ArchivedCombat[];
    /** The page number corresponding to the results that have been selected
             */
    pageNumber!: number;
    /** The page size used by the search
             */
    pageSize!: number;
    /** The total number of items matching the query
             */
    totalItemsCount!: number;
    /** The total number of pages
             */
    totalPagesCount!: number;

    constructor(data?: ISearchResultOfArchivedCombat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ArchivedCombat.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.totalItemsCount = _data["totalItemsCount"];
            this.totalPagesCount = _data["totalPagesCount"];
        }
    }

    static fromJS(data: any): SearchResultOfArchivedCombat {
        data = typeof data === 'object' ? data : {};
        let result = new SearchResultOfArchivedCombat();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalItemsCount"] = this.totalItemsCount;
        data["totalPagesCount"] = this.totalPagesCount;
        return data;
    }
}

/** Search result */
export interface ISearchResultOfArchivedCombat {
    /** The items found by the query
             */
    items: ArchivedCombat[];
    /** The page number corresponding to the results that have been selected
             */
    pageNumber: number;
    /** The page size used by the search
             */
    pageSize: number;
    /** The total number of items matching the query
             */
    totalItemsCount: number;
    /** The total number of pages
             */
    totalPagesCount: number;
}

/** Archived combat */
export class ArchivedCombat implements IArchivedCombat {
    /** The unique ID of the combat
             */
    id!: string;
    /** The attackers in the combat
             */
    attackers!: EntityMinimal[];
    /** The defenders in the combat
             */
    defenders!: EntityMinimal[];
    /** The winner of the combat
             */
    winner!: CombatSide;
    /** The duration of the combat
             */
    duration!: number;

    constructor(data?: IArchivedCombat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.attackers = [];
            this.defenders = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["attackers"])) {
                this.attackers = [] as any;
                for (let item of _data["attackers"])
                    this.attackers!.push(EntityMinimal.fromJS(item));
            }
            if (Array.isArray(_data["defenders"])) {
                this.defenders = [] as any;
                for (let item of _data["defenders"])
                    this.defenders!.push(EntityMinimal.fromJS(item));
            }
            this.winner = _data["winner"];
            this.duration = _data["duration"];
        }
    }

    static fromJS(data: any): ArchivedCombat {
        data = typeof data === 'object' ? data : {};
        let result = new ArchivedCombat();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.attackers)) {
            data["attackers"] = [];
            for (let item of this.attackers)
                data["attackers"].push(item.toJSON());
        }
        if (Array.isArray(this.defenders)) {
            data["defenders"] = [];
            for (let item of this.defenders)
                data["defenders"].push(item.toJSON());
        }
        data["winner"] = this.winner;
        data["duration"] = this.duration;
        return data;
    }
}

/** Archived combat */
export interface IArchivedCombat {
    /** The unique ID of the combat
             */
    id: string;
    /** The attackers in the combat
             */
    attackers: EntityMinimal[];
    /** The defenders in the combat
             */
    defenders: EntityMinimal[];
    /** The winner of the combat
             */
    winner: CombatSide;
    /** The duration of the combat
             */
    duration: number;
}

/** Character class */
export class CharacterClass extends CharacterClassMinimal implements ICharacterClass {
    /** The description of the character class
             */
    description!: string;
    /** The level caps of the character class
             */
    levelCaps!: number[];

    constructor(data?: ICharacterClass) {
        super(data);
        if (!data) {
            this.levelCaps = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.description = _data["description"];
            if (Array.isArray(_data["levelCaps"])) {
                this.levelCaps = [] as any;
                for (let item of _data["levelCaps"])
                    this.levelCaps!.push(item);
            }
        }
    }

    static override fromJS(data: any): CharacterClass {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterClass();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        if (Array.isArray(this.levelCaps)) {
            data["levelCaps"] = [];
            for (let item of this.levelCaps)
                data["levelCaps"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

/** Character class */
export interface ICharacterClass extends ICharacterClassMinimal {
    /** The description of the character class
             */
    description: string;
    /** The level caps of the character class
             */
    levelCaps: number[];
}

/** Item */
export class Item extends ItemMinimal implements IItem {
    /** The description of the item
             */
    description?: string | undefined;

    constructor(data?: IItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.description = _data["description"];
        }
    }

    static override fromJS(data: any): Item {
        data = typeof data === 'object' ? data : {};
        let result = new Item();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        super.toJSON(data);
        return data;
    }
}

/** Item */
export interface IItem extends IItemMinimal {
    /** The description of the item
             */
    description?: string | undefined;
}

/** Map location */
export class Location extends LocationMinimal implements ILocation {
    /** Has this location been discovered by the player.
If false, the connected locations will be hidden.
             */
    discovered!: boolean;
    /** The locations connected to this one
             */
    connectedLocations!: LocationMinimal[];

    constructor(data?: ILocation) {
        super(data);
        if (!data) {
            this.connectedLocations = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.discovered = _data["discovered"];
            if (Array.isArray(_data["connectedLocations"])) {
                this.connectedLocations = [] as any;
                for (let item of _data["connectedLocations"])
                    this.connectedLocations!.push(LocationMinimal.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Location {
        data = typeof data === 'object' ? data : {};
        let result = new Location();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discovered"] = this.discovered;
        if (Array.isArray(this.connectedLocations)) {
            data["connectedLocations"] = [];
            for (let item of this.connectedLocations)
                data["connectedLocations"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Map location */
export interface ILocation extends ILocationMinimal {
    /** Has this location been discovered by the player.
If false, the connected locations will be hidden.
             */
    discovered: boolean;
    /** The locations connected to this one
             */
    connectedLocations: LocationMinimal[];
}

/** Job */
export class Job extends JobMinimal implements IJob {
    /** The description of the job
             */
    description?: string | undefined;
    /** Is the job innate?
             */
    innate!: boolean;
    /** The experience to reach each level of the job
             */
    levelCaps!: number[];
    /** The harvests provided by the job
             */
    harvests!: HarvestableEntityHarvestMinimal[];

    constructor(data?: IJob) {
        super(data);
        if (!data) {
            this.levelCaps = [];
            this.harvests = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.description = _data["description"];
            this.innate = _data["innate"];
            if (Array.isArray(_data["levelCaps"])) {
                this.levelCaps = [] as any;
                for (let item of _data["levelCaps"])
                    this.levelCaps!.push(item);
            }
            if (Array.isArray(_data["harvests"])) {
                this.harvests = [] as any;
                for (let item of _data["harvests"])
                    this.harvests!.push(HarvestableEntityHarvestMinimal.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Job {
        data = typeof data === 'object' ? data : {};
        let result = new Job();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["innate"] = this.innate;
        if (Array.isArray(this.levelCaps)) {
            data["levelCaps"] = [];
            for (let item of this.levelCaps)
                data["levelCaps"].push(item);
        }
        if (Array.isArray(this.harvests)) {
            data["harvests"] = [];
            for (let item of this.harvests)
                data["harvests"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Job */
export interface IJob extends IJobMinimal {
    /** The description of the job
             */
    description?: string | undefined;
    /** Is the job innate?
             */
    innate: boolean;
    /** The experience to reach each level of the job
             */
    levelCaps: number[];
    /** The harvests provided by the job
             */
    harvests: HarvestableEntityHarvestMinimal[];
}

/** Game settings */
export class GameSettings implements IGameSettings {
    /** The max number of characters in a team
             */
    maxTeamSize!: number;

    constructor(data?: IGameSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxTeamSize = _data["maxTeamSize"];
        }
    }

    static fromJS(data: any): GameSettings {
        data = typeof data === 'object' ? data : {};
        let result = new GameSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxTeamSize"] = this.maxTeamSize;
        return data;
    }
}

/** Game settings */
export interface IGameSettings {
    /** The max number of characters in a team
             */
    maxTeamSize: number;
}

/** Game state */
export class GameState implements IGameState {
    /** The title of the game
             */
    title!: string;
    /** The current game tick
             */
    tick!: number;
    /** Is the next tick being computed.
In that case NextTickDate refers to the old tick's next tick date, which means that it is probably in the past.
             */
    isComputingNextTick!: boolean;
    /** Is the game paused?
             */
    paused!: boolean;
    /** If the game is started, the date at which last tick has been computed
             */
    lastTickDate?: Date | undefined;
    /** If the game is not paused, the date at which next tick will be computed
             */
    nextTickDate?: Date | undefined;

    constructor(data?: IGameState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.tick = _data["tick"];
            this.isComputingNextTick = _data["isComputingNextTick"];
            this.paused = _data["paused"];
            this.lastTickDate = _data["lastTickDate"] ? new Date(_data["lastTickDate"].toString()) : <any>undefined;
            this.nextTickDate = _data["nextTickDate"] ? new Date(_data["nextTickDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GameState {
        data = typeof data === 'object' ? data : {};
        let result = new GameState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["tick"] = this.tick;
        data["isComputingNextTick"] = this.isComputingNextTick;
        data["paused"] = this.paused;
        data["lastTickDate"] = this.lastTickDate ? this.lastTickDate.toISOString() : <any>undefined;
        data["nextTickDate"] = this.nextTickDate ? this.nextTickDate.toISOString() : <any>undefined;
        return data;
    }
}

/** Game state */
export interface IGameState {
    /** The title of the game
             */
    title: string;
    /** The current game tick
             */
    tick: number;
    /** Is the next tick being computed.
In that case NextTickDate refers to the old tick's next tick date, which means that it is probably in the past.
             */
    isComputingNextTick: boolean;
    /** Is the game paused?
             */
    paused: boolean;
    /** If the game is started, the date at which last tick has been computed
             */
    lastTickDate?: Date | undefined;
    /** If the game is not paused, the date at which next tick will be computed
             */
    nextTickDate?: Date | undefined;
}

/** Harvestable entity */
export class HarvestableEntity extends EntityMinimal implements IHarvestableEntity {
    /** The harvests available on the entity
             */
    harvests!: HarvestableEntityHarvest[];

    constructor(data?: IHarvestableEntity) {
        super(data);
        if (!data) {
            this.harvests = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["harvests"])) {
                this.harvests = [] as any;
                for (let item of _data["harvests"])
                    this.harvests!.push(HarvestableEntityHarvest.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): HarvestableEntity {
        data = typeof data === 'object' ? data : {};
        let result = new HarvestableEntity();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.harvests)) {
            data["harvests"] = [];
            for (let item of this.harvests)
                data["harvests"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Harvestable entity */
export interface IHarvestableEntity extends IEntityMinimal {
    /** The harvests available on the entity
             */
    harvests: HarvestableEntityHarvest[];
}

/** Harvestable entity harvest */
export class HarvestableEntityHarvest extends HarvestableEntityHarvestMinimal implements IHarvestableEntityHarvest {
    /** Can the harvest be performed
             */
    canHarvest!: boolean;
    /** Why cannot the harvest be performed
             */
    whyCannotHarvest?: string | undefined;

    constructor(data?: IHarvestableEntityHarvest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.canHarvest = _data["canHarvest"];
            this.whyCannotHarvest = _data["whyCannotHarvest"];
        }
    }

    static override fromJS(data: any): HarvestableEntityHarvest {
        data = typeof data === 'object' ? data : {};
        let result = new HarvestableEntityHarvest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canHarvest"] = this.canHarvest;
        data["whyCannotHarvest"] = this.whyCannotHarvest;
        super.toJSON(data);
        return data;
    }
}

/** Harvestable entity harvest */
export interface IHarvestableEntityHarvest extends IHarvestableEntityHarvestMinimal {
    /** Can the harvest be performed
             */
    canHarvest: boolean;
    /** Why cannot the harvest be performed
             */
    whyCannotHarvest?: string | undefined;
}

/** Location with access */
export class LocationWithAccess implements ILocationWithAccess {
    /** The location
             */
    location!: LocationMinimal;
    /** Is the location accessible
             */
    isAccessible!: boolean;
    /** Why is the location not accessible
             */
    whyIsNotAccessible?: string | undefined;

    constructor(data?: ILocationWithAccess) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.location = new LocationMinimal();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.location = _data["location"] ? LocationMinimal.fromJS(_data["location"]) : new LocationMinimal();
            this.isAccessible = _data["isAccessible"];
            this.whyIsNotAccessible = _data["whyIsNotAccessible"];
        }
    }

    static fromJS(data: any): LocationWithAccess {
        data = typeof data === 'object' ? data : {};
        let result = new LocationWithAccess();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["isAccessible"] = this.isAccessible;
        data["whyIsNotAccessible"] = this.whyIsNotAccessible;
        return data;
    }
}

/** Location with access */
export interface ILocationWithAccess {
    /** The location
             */
    location: LocationMinimal;
    /** Is the location accessible
             */
    isAccessible: boolean;
    /** Why is the location not accessible
             */
    whyIsNotAccessible?: string | undefined;
}

/** Monster group */
export class MonsterGroup extends MonsterGroupMinimal implements IMonsterGroup {
    /** Is the monster group being attacked
             */
    attacked!: boolean;
    /** Can the character attack the monsters
             */
    canAttackOrJoin!: boolean;
    /** Why cannot the character attack the monsters
             */
    whyCannotAttackOrJoin?: string | undefined;

    constructor(data?: IMonsterGroup) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.attacked = _data["attacked"];
            this.canAttackOrJoin = _data["canAttackOrJoin"];
            this.whyCannotAttackOrJoin = _data["whyCannotAttackOrJoin"];
        }
    }

    static override fromJS(data: any): MonsterGroup {
        data = typeof data === 'object' ? data : {};
        let result = new MonsterGroup();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attacked"] = this.attacked;
        data["canAttackOrJoin"] = this.canAttackOrJoin;
        data["whyCannotAttackOrJoin"] = this.whyCannotAttackOrJoin;
        super.toJSON(data);
        return data;
    }
}

/** Monster group */
export interface IMonsterGroup extends IMonsterGroupMinimal {
    /** Is the monster group being attacked
             */
    attacked: boolean;
    /** Can the character attack the monsters
             */
    canAttackOrJoin: boolean;
    /** Why cannot the character attack the monsters
             */
    whyCannotAttackOrJoin?: string | undefined;
}

/** Team of characters */
export class Team implements ITeam {
    /** The characters in the team
             */
    characters!: TeamCharacter[];

    constructor(data?: ITeam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.characters = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["characters"])) {
                this.characters = [] as any;
                for (let item of _data["characters"])
                    this.characters!.push(TeamCharacter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Team {
        data = typeof data === 'object' ? data : {};
        let result = new Team();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.characters)) {
            data["characters"] = [];
            for (let item of this.characters)
                data["characters"].push(item.toJSON());
        }
        return data;
    }
}

/** Team of characters */
export interface ITeam {
    /** The characters in the team
             */
    characters: TeamCharacter[];
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}