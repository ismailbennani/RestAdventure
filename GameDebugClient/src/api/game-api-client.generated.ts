//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class GameApiStatusApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7056";
    }

    /**
     * Ping
     */
    ping(): Observable<void> {
        let url_ = this.baseUrl + "/game/status/ping";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPing(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPing(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class GameContentApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7056";
    }

    /**
     * Get item
     */
    getItem(itemId: string): Observable<Item> {
        let url_ = this.baseUrl + "/game/content/items/{itemId}";
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Item>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Item>;
        }));
    }

    protected processGetItem(response: HttpResponseBase): Observable<Item> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Item.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get location
     */
    getLocation(locationId: string): Observable<Location> {
        let url_ = this.baseUrl + "/game/content/locations/{locationId}";
        if (locationId === undefined || locationId === null)
            throw new Error("The parameter 'locationId' must be defined.");
        url_ = url_.replace("{locationId}", encodeURIComponent("" + locationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Location>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Location>;
        }));
    }

    protected processGetLocation(response: HttpResponseBase): Observable<Location> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Location.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get job
     */
    getJob(jobId: string): Observable<Job> {
        let url_ = this.baseUrl + "/game/content/jobs/{jobId}";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJob(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Job>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Job>;
        }));
    }

    protected processGetJob(response: HttpResponseBase): Observable<Job> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Job.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get harvestable
     */
    getHarvestable(harvestableId: string): Observable<Harvestable> {
        let url_ = this.baseUrl + "/game/content/harvestables/{harvestableId}";
        if (harvestableId === undefined || harvestableId === null)
            throw new Error("The parameter 'harvestableId' must be defined.");
        url_ = url_.replace("{harvestableId}", encodeURIComponent("" + harvestableId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHarvestable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHarvestable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Harvestable>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Harvestable>;
        }));
    }

    protected processGetHarvestable(response: HttpResponseBase): Observable<Harvestable> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Harvestable.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class GameApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7056";
    }

    /**
     * Get game settings
     */
    getGameSettings(): Observable<GameSettings> {
        let url_ = this.baseUrl + "/game/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGameSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGameSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GameSettings>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GameSettings>;
        }));
    }

    protected processGetGameSettings(response: HttpResponseBase): Observable<GameSettings> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameSettings.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get game state
     */
    getGameState(): Observable<GameState> {
        let url_ = this.baseUrl + "/game/state";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGameState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGameState(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GameState>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GameState>;
        }));
    }

    protected processGetGameState(response: HttpResponseBase): Observable<GameState> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameState.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TeamCharactersActionsApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7056";
    }

    /**
     * Get accessible locations
     */
    getAccessibleLocations(characterGuid: string): Observable<LocationMinimal[]> {
        let url_ = this.baseUrl + "/game/team/characters/{characterGuid}/locations";
        if (characterGuid === undefined || characterGuid === null)
            throw new Error("The parameter 'characterGuid' must be defined.");
        url_ = url_.replace("{characterGuid}", encodeURIComponent("" + characterGuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccessibleLocations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccessibleLocations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LocationMinimal[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LocationMinimal[]>;
        }));
    }

    protected processGetAccessibleLocations(response: HttpResponseBase): Observable<LocationMinimal[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LocationMinimal.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Move to location
     */
    moveToLocation(characterGuid: string, locationGuid: string): Observable<void> {
        let url_ = this.baseUrl + "/game/team/characters/{characterGuid}/locations/{locationGuid}";
        if (characterGuid === undefined || characterGuid === null)
            throw new Error("The parameter 'characterGuid' must be defined.");
        url_ = url_.replace("{characterGuid}", encodeURIComponent("" + characterGuid));
        if (locationGuid === undefined || locationGuid === null)
            throw new Error("The parameter 'locationGuid' must be defined.");
        url_ = url_.replace("{locationGuid}", encodeURIComponent("" + locationGuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveToLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveToLocation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMoveToLocation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get available interactions
     */
    getAvailableInteractions(characterGuid: string): Observable<EntityWithInteractions[]> {
        let url_ = this.baseUrl + "/game/team/characters/{characterGuid}/interactions";
        if (characterGuid === undefined || characterGuid === null)
            throw new Error("The parameter 'characterGuid' must be defined.");
        url_ = url_.replace("{characterGuid}", encodeURIComponent("" + characterGuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvailableInteractions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailableInteractions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityWithInteractions[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityWithInteractions[]>;
        }));
    }

    protected processGetAvailableInteractions(response: HttpResponseBase): Observable<EntityWithInteractions[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityWithInteractions.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Interact
     */
    interact(characterGuid: string, entityGuid: string, interactionGuid: string): Observable<void> {
        let url_ = this.baseUrl + "/game/team/characters/{characterGuid}/interactions/entity/{entityGuid}/{interactionGuid}";
        if (characterGuid === undefined || characterGuid === null)
            throw new Error("The parameter 'characterGuid' must be defined.");
        url_ = url_.replace("{characterGuid}", encodeURIComponent("" + characterGuid));
        if (entityGuid === undefined || entityGuid === null)
            throw new Error("The parameter 'entityGuid' must be defined.");
        url_ = url_.replace("{entityGuid}", encodeURIComponent("" + entityGuid));
        if (interactionGuid === undefined || interactionGuid === null)
            throw new Error("The parameter 'interactionGuid' must be defined.");
        url_ = url_.replace("{interactionGuid}", encodeURIComponent("" + interactionGuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInteract(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInteract(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInteract(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TeamCharactersApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7056";
    }

    /**
     * Create character
     */
    createCharacter(request: CreateCharacterRequest): Observable<TeamCharacter> {
        let url_ = this.baseUrl + "/game/team/characters";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCharacter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCharacter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeamCharacter>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeamCharacter>;
        }));
    }

    protected processCreateCharacter(response: HttpResponseBase): Observable<TeamCharacter> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeamCharacter.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete character
     */
    deleteCharacter(characterGuid: string): Observable<void> {
        let url_ = this.baseUrl + "/game/team/characters/{characterGuid}";
        if (characterGuid === undefined || characterGuid === null)
            throw new Error("The parameter 'characterGuid' must be defined.");
        url_ = url_.replace("{characterGuid}", encodeURIComponent("" + characterGuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCharacter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCharacter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteCharacter(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TeamApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7056";
    }

    /**
     * Get team
     */
    getTeam(): Observable<Team> {
        let url_ = this.baseUrl + "/game/team";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeam(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeam(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Team>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Team>;
        }));
    }

    protected processGetTeam(response: HttpResponseBase): Observable<Team> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Team.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

/** Item */
export class Item implements IItem {
    /** The unique ID of the item
             */
    id!: string;
    /** The name of the item
             */
    name!: string;
    /** The description of the item
             */
    description?: string | undefined;
    /** The weight of the item
             */
    weight!: number;

    constructor(data?: IItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.weight = _data["weight"];
        }
    }

    static fromJS(data: any): Item {
        data = typeof data === 'object' ? data : {};
        let result = new Item();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["weight"] = this.weight;
        return data;
    }
}

/** Item */
export interface IItem {
    /** The unique ID of the item
             */
    id: string;
    /** The name of the item
             */
    name: string;
    /** The description of the item
             */
    description?: string | undefined;
    /** The weight of the item
             */
    weight: number;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

/** Map location minimal information */
export class LocationMinimal implements ILocationMinimal {
    /** The unique ID of the location
             */
    id!: string;
    /** The area associated with the location
             */
    area!: MapArea;
    /** The X coordinate associated with the location
             */
    positionX!: number;
    /** The Y coordinate associated with the location
             */
    positionY!: number;

    constructor(data?: ILocationMinimal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.area = new MapArea();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.area = _data["area"] ? MapArea.fromJS(_data["area"]) : new MapArea();
            this.positionX = _data["positionX"];
            this.positionY = _data["positionY"];
        }
    }

    static fromJS(data: any): LocationMinimal {
        data = typeof data === 'object' ? data : {};
        let result = new LocationMinimal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["area"] = this.area ? this.area.toJSON() : <any>undefined;
        data["positionX"] = this.positionX;
        data["positionY"] = this.positionY;
        return data;
    }
}

/** Map location minimal information */
export interface ILocationMinimal {
    /** The unique ID of the location
             */
    id: string;
    /** The area associated with the location
             */
    area: MapArea;
    /** The X coordinate associated with the location
             */
    positionX: number;
    /** The Y coordinate associated with the location
             */
    positionY: number;
}

/** Map location */
export class Location extends LocationMinimal implements ILocation {
    /** Has this location been discovered by the player.
If false, the connected locations will be hidden.
             */
    discovered!: boolean;
    /** The locations connected to this one
             */
    connectedLocations!: LocationMinimal[];

    constructor(data?: ILocation) {
        super(data);
        if (!data) {
            this.connectedLocations = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.discovered = _data["discovered"];
            if (Array.isArray(_data["connectedLocations"])) {
                this.connectedLocations = [] as any;
                for (let item of _data["connectedLocations"])
                    this.connectedLocations!.push(LocationMinimal.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Location {
        data = typeof data === 'object' ? data : {};
        let result = new Location();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discovered"] = this.discovered;
        if (Array.isArray(this.connectedLocations)) {
            data["connectedLocations"] = [];
            for (let item of this.connectedLocations)
                data["connectedLocations"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Map location */
export interface ILocation extends ILocationMinimal {
    /** Has this location been discovered by the player.
If false, the connected locations will be hidden.
             */
    discovered: boolean;
    /** The locations connected to this one
             */
    connectedLocations: LocationMinimal[];
}

/** Map area */
export class MapArea implements IMapArea {
    /** The unique ID of the area
             */
    id!: string;
    /** The name of the area
             */
    name!: string;

    constructor(data?: IMapArea) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): MapArea {
        data = typeof data === 'object' ? data : {};
        let result = new MapArea();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

/** Map area */
export interface IMapArea {
    /** The unique ID of the area
             */
    id: string;
    /** The name of the area
             */
    name: string;
}

/** Job (minimal) */
export class JobMinimal implements IJobMinimal {
    /** The unique ID of the job
             */
    id!: string;
    /** The name of the job
             */
    name!: string;

    constructor(data?: IJobMinimal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): JobMinimal {
        data = typeof data === 'object' ? data : {};
        let result = new JobMinimal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

/** Job (minimal) */
export interface IJobMinimal {
    /** The unique ID of the job
             */
    id: string;
    /** The name of the job
             */
    name: string;
}

/** Job */
export class Job extends JobMinimal implements IJob {
    /** The description of the job
             */
    description?: string | undefined;
    /** Is the job innate?
             */
    innate!: boolean;
    /** The experience to reach each level of the job.
             */
    levelsExperience!: number[];

    constructor(data?: IJob) {
        super(data);
        if (!data) {
            this.levelsExperience = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.description = _data["description"];
            this.innate = _data["innate"];
            if (Array.isArray(_data["levelsExperience"])) {
                this.levelsExperience = [] as any;
                for (let item of _data["levelsExperience"])
                    this.levelsExperience!.push(item);
            }
        }
    }

    static override fromJS(data: any): Job {
        data = typeof data === 'object' ? data : {};
        let result = new Job();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["innate"] = this.innate;
        if (Array.isArray(this.levelsExperience)) {
            data["levelsExperience"] = [];
            for (let item of this.levelsExperience)
                data["levelsExperience"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

/** Job */
export interface IJob extends IJobMinimal {
    /** The description of the job
             */
    description?: string | undefined;
    /** Is the job innate?
             */
    innate: boolean;
    /** The experience to reach each level of the job.
             */
    levelsExperience: number[];
}

/** Harvestable */
export class Harvestable implements IHarvestable {
    /** The unique ID of the harvestable
             */
    id!: string;
    /** The name of the harvestable
             */
    name!: string;
    /** The description of the harvestable
             */
    description?: string | undefined;

    constructor(data?: IHarvestable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): Harvestable {
        data = typeof data === 'object' ? data : {};
        let result = new Harvestable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

/** Harvestable */
export interface IHarvestable {
    /** The unique ID of the harvestable
             */
    id: string;
    /** The name of the harvestable
             */
    name: string;
    /** The description of the harvestable
             */
    description?: string | undefined;
}

export class GameSettings implements IGameSettings {
    maxTeamSize?: number;

    constructor(data?: IGameSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxTeamSize = _data["maxTeamSize"];
        }
    }

    static fromJS(data: any): GameSettings {
        data = typeof data === 'object' ? data : {};
        let result = new GameSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxTeamSize"] = this.maxTeamSize;
        return data;
    }
}

export interface IGameSettings {
    maxTeamSize?: number;
}

/** Game state */
export class GameState implements IGameState {
    /** The current game tick
             */
    tick!: number;
    /** Is the game paused?
             */
    paused!: boolean;
    /** If the game is started, the date at which last tick has been computed
             */
    lastTickDate!: Date;
    /** If the game is not paused, the date at which next tick will be computed
             */
    nextTickDate!: Date;

    constructor(data?: IGameState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tick = _data["tick"];
            this.paused = _data["paused"];
            this.lastTickDate = _data["lastTickDate"] ? new Date(_data["lastTickDate"].toString()) : <any>undefined;
            this.nextTickDate = _data["nextTickDate"] ? new Date(_data["nextTickDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GameState {
        data = typeof data === 'object' ? data : {};
        let result = new GameState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tick"] = this.tick;
        data["paused"] = this.paused;
        data["lastTickDate"] = this.lastTickDate ? this.lastTickDate.toISOString() : <any>undefined;
        data["nextTickDate"] = this.nextTickDate ? this.nextTickDate.toISOString() : <any>undefined;
        return data;
    }
}

/** Game state */
export interface IGameState {
    /** The current game tick
             */
    tick: number;
    /** Is the game paused?
             */
    paused: boolean;
    /** If the game is started, the date at which last tick has been computed
             */
    lastTickDate: Date;
    /** If the game is not paused, the date at which next tick will be computed
             */
    nextTickDate: Date;
}

/** Entity (minimal) */
export class EntityMinimal implements IEntityMinimal {
    /** The unique ID of the entity
             */
    id!: string;
    /** The name of the entity
             */
    name!: string;

    constructor(data?: IEntityMinimal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EntityMinimal {
        data = typeof data === 'object' ? data : {};
        let result = new EntityMinimal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

/** Entity (minimal) */
export interface IEntityMinimal {
    /** The unique ID of the entity
             */
    id: string;
    /** The name of the entity
             */
    name: string;
}

/** Entity with interactions */
export class EntityWithInteractions extends EntityMinimal implements IEntityWithInteractions {
    /** The interactions that can be performed on the entity
             */
    interactions!: Interaction[];

    constructor(data?: IEntityWithInteractions) {
        super(data);
        if (!data) {
            this.interactions = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["interactions"])) {
                this.interactions = [] as any;
                for (let item of _data["interactions"])
                    this.interactions!.push(Interaction.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): EntityWithInteractions {
        data = typeof data === 'object' ? data : {};
        let result = new EntityWithInteractions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.interactions)) {
            data["interactions"] = [];
            for (let item of this.interactions)
                data["interactions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Entity with interactions */
export interface IEntityWithInteractions extends IEntityMinimal {
    /** The interactions that can be performed on the entity
             */
    interactions: Interaction[];
}

/** Interaction (minimal) */
export class InteractionMinimal implements IInteractionMinimal {
    /** The unique ID of the interaction
             */
    id!: string;
    /** The name of the interaction
             */
    name!: string;

    constructor(data?: IInteractionMinimal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): InteractionMinimal {
        data = typeof data === 'object' ? data : {};
        let result = new InteractionMinimal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

/** Interaction (minimal) */
export interface IInteractionMinimal {
    /** The unique ID of the interaction
             */
    id: string;
    /** The name of the interaction
             */
    name: string;
}

/** Interaction */
export class Interaction extends InteractionMinimal implements IInteraction {
    /** Can this interaction be performed
             */
    canInteract!: boolean;

    constructor(data?: IInteraction) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.canInteract = _data["canInteract"];
        }
    }

    static override fromJS(data: any): Interaction {
        data = typeof data === 'object' ? data : {};
        let result = new Interaction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canInteract"] = this.canInteract;
        super.toJSON(data);
        return data;
    }
}

/** Interaction */
export interface IInteraction extends IInteractionMinimal {
    /** Can this interaction be performed
             */
    canInteract: boolean;
}

/** Character */
export class TeamCharacter implements ITeamCharacter {
    /** The unique ID of the character
             */
    id!: string;
    /** The name of the character
             */
    name!: string;
    /** The class of the character
             */
    class!: CharacterClass;
    /** The current location of the character
             */
    location!: LocationMinimal;
    /** The inventory of the character
             */
    inventory!: Inventory;
    /** The result of the action that has been performed on last tick
             */
    lastActionResult?: CharacterActionResult | undefined;
    /** The action that the character has planned for the next tick
             */
    nextAction?: CharacterAction | undefined;

    constructor(data?: ITeamCharacter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.location = new LocationMinimal();
            this.inventory = new Inventory();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.class = _data["class"];
            this.location = _data["location"] ? LocationMinimal.fromJS(_data["location"]) : new LocationMinimal();
            this.inventory = _data["inventory"] ? Inventory.fromJS(_data["inventory"]) : new Inventory();
            this.lastActionResult = _data["lastActionResult"] ? CharacterActionResult.fromJS(_data["lastActionResult"]) : <any>undefined;
            this.nextAction = _data["nextAction"] ? CharacterAction.fromJS(_data["nextAction"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TeamCharacter {
        data = typeof data === 'object' ? data : {};
        let result = new TeamCharacter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["class"] = this.class;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["inventory"] = this.inventory ? this.inventory.toJSON() : <any>undefined;
        data["lastActionResult"] = this.lastActionResult ? this.lastActionResult.toJSON() : <any>undefined;
        data["nextAction"] = this.nextAction ? this.nextAction.toJSON() : <any>undefined;
        return data;
    }
}

/** Character */
export interface ITeamCharacter {
    /** The unique ID of the character
             */
    id: string;
    /** The name of the character
             */
    name: string;
    /** The class of the character
             */
    class: CharacterClass;
    /** The current location of the character
             */
    location: LocationMinimal;
    /** The inventory of the character
             */
    inventory: Inventory;
    /** The result of the action that has been performed on last tick
             */
    lastActionResult?: CharacterActionResult | undefined;
    /** The action that the character has planned for the next tick
             */
    nextAction?: CharacterAction | undefined;
}

export enum CharacterClass {
    Knight = "knight",
    Mage = "mage",
    Scout = "scout",
    Dealer = "dealer",
}

/** Inventory */
export class Inventory implements IInventory {
    /** The entries of the inventory
             */
    entries!: ItemStack[];
    /** The total weight of the items in the inventory
             */
    weight!: number;

    constructor(data?: IInventory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.entries = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["entries"])) {
                this.entries = [] as any;
                for (let item of _data["entries"])
                    this.entries!.push(ItemStack.fromJS(item));
            }
            this.weight = _data["weight"];
        }
    }

    static fromJS(data: any): Inventory {
        data = typeof data === 'object' ? data : {};
        let result = new Inventory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.entries)) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        data["weight"] = this.weight;
        return data;
    }
}

/** Inventory */
export interface IInventory {
    /** The entries of the inventory
             */
    entries: ItemStack[];
    /** The total weight of the items in the inventory
             */
    weight: number;
}

/** Item stack */
export class ItemStack implements IItemStack {
    /** The item instance representing this stack
             */
    itemInstance!: ItemInstance;
    /** The number of instances in this stack
             */
    count!: number;

    constructor(data?: IItemStack) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.itemInstance = new ItemInstance();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemInstance = _data["itemInstance"] ? ItemInstance.fromJS(_data["itemInstance"]) : new ItemInstance();
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): ItemStack {
        data = typeof data === 'object' ? data : {};
        let result = new ItemStack();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemInstance"] = this.itemInstance ? this.itemInstance.toJSON() : <any>undefined;
        data["count"] = this.count;
        return data;
    }
}

/** Item stack */
export interface IItemStack {
    /** The item instance representing this stack
             */
    itemInstance: ItemInstance;
    /** The number of instances in this stack
             */
    count: number;
}

/** Item instance */
export class ItemInstance implements IItemInstance {
    /** The unique ID of this instance
             */
    id!: string;
    /** The unique ID of the item corresponding to this instance
             */
    itemId!: string;

    constructor(data?: IItemInstance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.itemId = _data["itemId"];
        }
    }

    static fromJS(data: any): ItemInstance {
        data = typeof data === 'object' ? data : {};
        let result = new ItemInstance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["itemId"] = this.itemId;
        return data;
    }
}

/** Item instance */
export interface IItemInstance {
    /** The unique ID of this instance
             */
    id: string;
    /** The unique ID of the item corresponding to this instance
             */
    itemId: string;
}

/** The result of an action performed by a character */
export class CharacterActionResult implements ICharacterActionResult {
    /** The tick at which the action has been performed
             */
    tick!: number;
    /** The action
             */
    action!: CharacterAction;
    /** Has the action been successful
             */
    success!: boolean;
    /** Why the action has failed
             */
    failureReason?: string | undefined;

    constructor(data?: ICharacterActionResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.action = new CharacterAction();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tick = _data["tick"];
            this.action = _data["action"] ? CharacterAction.fromJS(_data["action"]) : new CharacterAction();
            this.success = _data["success"];
            this.failureReason = _data["failureReason"];
        }
    }

    static fromJS(data: any): CharacterActionResult {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterActionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tick"] = this.tick;
        data["action"] = this.action ? this.action.toJSON() : <any>undefined;
        data["success"] = this.success;
        data["failureReason"] = this.failureReason;
        return data;
    }
}

/** The result of an action performed by a character */
export interface ICharacterActionResult {
    /** The tick at which the action has been performed
             */
    tick: number;
    /** The action
             */
    action: CharacterAction;
    /** Has the action been successful
             */
    success: boolean;
    /** Why the action has failed
             */
    failureReason?: string | undefined;
}

/** An action performed by a character */
export class CharacterAction implements ICharacterAction {

    protected _discriminator: string;

    constructor(data?: ICharacterAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "CharacterAction";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): CharacterAction {
        data = typeof data === 'object' ? data : {};
        if (data["$type"] === "move") {
            let result = new CharacterMoveToLocationAction();
            result.init(data);
            return result;
        }
        if (data["$type"] === "interact") {
            let result = new CharacterInteractWithEntityAction();
            result.init(data);
            return result;
        }
        let result = new CharacterAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$type"] = this._discriminator;
        return data;
    }
}

/** An action performed by a character */
export interface ICharacterAction {
}

/** Character moves to location */
export class CharacterMoveToLocationAction extends CharacterAction implements ICharacterMoveToLocationAction {
    /** The location to which the character is moving
             */
    location!: LocationMinimal;

    constructor(data?: ICharacterMoveToLocationAction) {
        super(data);
        if (!data) {
            this.location = new LocationMinimal();
        }
        this._discriminator = "move";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.location = _data["location"] ? LocationMinimal.fromJS(_data["location"]) : new LocationMinimal();
        }
    }

    static override fromJS(data: any): CharacterMoveToLocationAction {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterMoveToLocationAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Character moves to location */
export interface ICharacterMoveToLocationAction extends ICharacterAction {
    /** The location to which the character is moving
             */
    location: LocationMinimal;
}

/** Character interact with entity */
export class CharacterInteractWithEntityAction extends CharacterAction implements ICharacterInteractWithEntityAction {
    /** The interaction
             */
    interaction!: InteractionMinimal;
    /** The subject of the interaction
             */
    entity!: EntityMinimal;

    constructor(data?: ICharacterInteractWithEntityAction) {
        super(data);
        if (!data) {
            this.interaction = new InteractionMinimal();
            this.entity = new EntityMinimal();
        }
        this._discriminator = "interact";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.interaction = _data["interaction"] ? InteractionMinimal.fromJS(_data["interaction"]) : new InteractionMinimal();
            this.entity = _data["entity"] ? EntityMinimal.fromJS(_data["entity"]) : new EntityMinimal();
        }
    }

    static override fromJS(data: any): CharacterInteractWithEntityAction {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterInteractWithEntityAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["interaction"] = this.interaction ? this.interaction.toJSON() : <any>undefined;
        data["entity"] = this.entity ? this.entity.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Character interact with entity */
export interface ICharacterInteractWithEntityAction extends ICharacterAction {
    /** The interaction
             */
    interaction: InteractionMinimal;
    /** The subject of the interaction
             */
    entity: EntityMinimal;
}

/** Character creation options */
export class CreateCharacterRequest implements ICreateCharacterRequest {
    /** The name of the character
             */
    name!: string;
    /** The class of the character
             */
    class!: CharacterClass;

    constructor(data?: ICreateCharacterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.class = _data["class"];
        }
    }

    static fromJS(data: any): CreateCharacterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCharacterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["class"] = this.class;
        return data;
    }
}

/** Character creation options */
export interface ICreateCharacterRequest {
    /** The name of the character
             */
    name: string;
    /** The class of the character
             */
    class: CharacterClass;
}

/** Team of characters */
export class Team implements ITeam {
    /** The characters in the team
             */
    characters!: TeamCharacter[];

    constructor(data?: ITeam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.characters = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["characters"])) {
                this.characters = [] as any;
                for (let item of _data["characters"])
                    this.characters!.push(TeamCharacter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Team {
        data = typeof data === 'object' ? data : {};
        let result = new Team();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.characters)) {
            data["characters"] = [];
            for (let item of this.characters)
                data["characters"].push(item.toJSON());
        }
        return data;
    }
}

/** Team of characters */
export interface ITeam {
    /** The characters in the team
             */
    characters: TeamCharacter[];
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}